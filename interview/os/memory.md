---
date: 2022-10-29T12:59:45+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "内存管理"  # 文章标题
url:  "posts/cpp/interview/os/memory"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## 内存管理有哪几种方式

常见的内存管理方式有块式管理、页式管理、段式管理和段页式管理。最常用的是段页式管理。

1. 块式管理：把主存分为一大块一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断载入主存，就算所需的程序片段只有几个字节，也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了 50% 的内存空间，但是易于管理。

2. 页式管理：用户程序的地址空间被划分成若干个固定大小的区域，这个区域被称为“页”，相应地，内存空间也被划分为若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，从而实现了离散分配。这种方式的优点是页的大小是固定的，因此便于管理；缺点是页长与程序的逻辑大小没有任何关系。这就导致在某个时刻一个程序可能只有一部分在主存中，而另一部分则在辅存中。这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。

3. 段式管理：段是按照程序的自然分界划分的并且长度可以动态改变的区域。使用这种方式，程序员可以把子程序、操作数和不同类型的数据和函数划分到不同的段中。这种方式将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。

分段存储主要有如下优点：

① 段的逻辑独立性不仅使其易于编译、管理、修改和保护，也便于多道程序共享。

② 段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。

③ 方便分段共享、分段保护、动态链接、动态增长。

分段存储的缺点如下：

① 由于段的大小不固定，因此存储管理比较麻烦。

② 会生成段内碎片，这会造成存储空间利用率降低。而且段式存储管理比页式存储管理方式需要更多的硬件支持。

正是由于页式管理和段式管理都有各种各样的缺点，因此，为了把这两种存储方式的优点结合起来，新引入了段页式管理。

4. 段页式管理：段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。

① 用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。

② 用分页方法来分配和管理内存，即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护。

## 什么是虚拟内存

虚拟内存简称虚存，是计算机系统内存管理的一种技术。它是相对于物理内存而言的，可以理解为“假的”内存。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），允许程序员编写并运行比实际系统拥有的内存大得多的程序，这使得许多大型软件项目能够在具有有限内存资源的系统上实现。而实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。相比实存，虚存有以下好处：

1. 扩大了地址空间。无论是段式虚存，还是页式虚存，或是段页式虚存，寻址空间都比实存大。

2. 内存保护。每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。另外，虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。

3. 公平分配内存。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。

4. 当进程需要通信时，可采用虚存共享的方式实现。

不过，使用虚存也是有代价的，主要表现在以下几个方面：

1. 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存。

2. 虚拟地址到物理地址的转换，增加了指令的执行时间。

3. 页面的换入换出需要磁盘 I/O，这是很耗时间的。

4. 如果一页中只有一部分数据，会浪费内存。

## 什么是内存碎片？什么是内碎片？什么是外碎片

内存碎片是由于多次进行内存分配造成的，当进行内存分配时，内存格式一般为：（用户使用段）（空白段）（用户使用段），当空白段很小的时候，可能不能提供给用户足够多的空间，如夹在中间的空白段的大小为 5，而用户需要的内存大小为 6，这样会产生很多的间隙，造成使用效率下降，这些很小的空隙叫碎片。

内碎片：分配给程序的存储空间没有用完，有一部分是程序不使用，但其他程序也没法用的空间。内碎片是处于区域内部或页面内部的存储块，占有这些区域或页面的进程并不使用这个存储块，而在进程占有这块存储块时，系统无法利用它，直到进程释放它，或进程结束时，系统才有可能利用这个存储块。

外碎片：空间太小，小到无法给任何程序分配（不属于任何进程）的存储空间。外部碎片是出于任何已分配区域或页面外部的空闲存储块，这些存储块的总和可以满足当前申请的长度要求，但是它们的地址不连续或其他原因，使得系统无法满足当前申请。

内碎片和外碎片是一对矛盾体，一种特定的内存分配算法，很难同时解决好内碎片和外碎片的问题，只能根据应用特点进行取舍。

## 虚拟地址、逻辑地址、线性地址、物理地址有什么区别

虚拟地址是指由程序产生的**由段选择符和段内偏移地址组成的地址**。这两部分组成的地址并没有直接访问物理内存，而是通过分段地址的变换处理后才会对应到相应的物理内存地址。

逻辑地址指由程序产生的**段内偏移地址**。有时直接把逻辑地址当成虚拟地址，两者并没有明确的界限。

线性地址是指**虚拟地址到物理地址变换之间的中间层**，是处理器可寻址的内存空间（称为线性地址空间）中的地址。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段基址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若没有采用分页机制，那么线性地址就是物理地址。

物理地址是指现在 CPU 外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。

虚拟地址到物理地址的转化方法是与体系结构相关的，一般有分段与分页两种方式。以 x86 CPU 为例，分段、分页都是支持的。内存管理单元负责从虚拟地址到物理地址的转化。逻辑地址是段标识 + 段内偏移量的形式，MMU 通过查询段表，可以把逻辑地址转化为线性地址。如果 CPU 没有开启分页功能，那么线性地址就是物理地址；如果 CPU 开启了分页功能， MMU 还需要**查询页表来将线性地址转化为物理地址**：逻辑地址（段表）→线性地址（页表）→物理地址。

映射是一种多对一的关系，即不同的逻辑地址可以映射到同一个线性地址上；不同的线性地址也可以映射到同一个物理地址上。而且，同一个线性地址在发生换页以后，也可能被重新装载到另外一个物理地址上，所以这种多对一的映射关系也会随时间发生变化。

## Cache 替换算法有哪些

数据可以存放在 CPU 或者内存中。CPU 处理快，但是容量少；内存容量大，但是转交给 CPU 处理的速度慢。为此，需要 Cache 缓存来做一个折中。最有可能的数据先从内存调入 Cache，CPU 再从 Cache 读取数据，这样会快许多。然而，Cache 中所存放的数据不是 100% 有用的。CPU 从 Cache 中读取到有用数据称为“命中”。

由于主存中的块比 Cache 中的块多，所以当要从主存中调一个块到 Cache 中时，会出现该块所映射到的一组（或一个）Cache 块已全部被占用的情况。此时，需要被迫腾出其中的某一块，以接纳新调入的块，这就是替换。

Cache 替换算法有 RAND 算法、FIFO 算法、LRU 算法、OPT 算法和 LFU 算法。

1. 随机 (RAND) 算法。随机算法就是**用随机数发生器产生一个要替换的块号，将该块替换出去**，此算法简单、易于实现，而且它不考虑 Cache 块过去、现在及将来的使用情况。但是，由于没有利用上层存储器使用的“历史信息”、没有根据访存的局部性原理，故不能提高 Cache 的命中率，命中率较低。

2. 先进先出 (FIFO) 算法。先进先出 (First In First Out, FIFO) 算法是将最先进入 Cache 的信息块替换出去。FIFO 算法按调入 Cache 的先后决定淘汰的顺序，选择最早调入 Cache 的字块进行替换，它不需要记录各字块的使用情况，比较容易实现，系统开销小，其缺点是可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入 Cache 的块替换掉，而且没有根据访存的局部性原理，故不能提高 Cache 的命中率。因为最早调入的信息可能以后还要用到，或者经常要用到，如循环程序。此法简单、方便，利用了主存的“历史信息”，但并不能说最先进入的就不经常使用，其缺点是不能正确反映程序局部性原理，命中率不高，可能出现一种异常现象。例如，Solar-16/65 机 Cache 采用组相连方式，每组 4 块，每块都设定一个两位的计数器，当某块被装入或被替换时该块的计数器清为 0，而同组的其他各块的计数器均加 1，当需要替换时就选择计数值最大的块被替换掉。

3. 最优替换 (OPT) 算法。使用最优替换 (OPTimal replacement, OPT) 算法时必须先执行一次程序，统计 Cache 的替换情况。有了这样的先验信息，在第二次执行该程序时便可以用最有效的方式来替换，以达到最优的目的。

前面介绍的几种页面替换算法主要是以主存储器中页面调度情况的历史信息为依据的，它假设将来主存储器中的页面调度情况与过去一段时间内主存储器中的页面调度情况是相同的，显然，这种假设不总是正确的。最好的算法应该是选择将来最久不被访问的页面作为被替换的页面，这种替换算法的命中率一定是最高的，它就是最优替换算法。

要实现 OPT 算法，唯一的办法是让程序先执行一遍，记录下实际的页地址的使用情况。根据这个页地址的使用情况才能找出当前要被替换的页面。显然，这样做是不现实的。因此，OPT 算法只是一种理想化的算法，然而，它也是一种很有用的算法。实际上，经常把这种算法用来作为评价其他页面替换算法好坏的标准。在其他条件相同的情况下，哪一种页面替换算法的命中率与 OPT 算法最接近，那么它就是一种比较好的页面替换算法。

### LRU 和 LFU

LRU，即：最近最少使用淘汰算法（Least Recently Used）。LRU 是淘汰最长时间没有被使用的页面。比如有一个页面最近 0 次使用，而其它页面活页，但在最后一刻，这个页面被使用了，那么它不会被淘汰，反而淘汰了之前活跃的页面。

LFU，即：最不经常使用淘汰算法（Least Frequently Used）。LFU 是淘汰一段时间内，使用次数最少的页面。比如一个页面这段时间内，开始时被使用了 99 次，然后就一直不使用了，结果到了最后一刻，其它页面比它使用次数少，这个页面不会被淘汰。

```c++

```
