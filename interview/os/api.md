---
date: 2022-10-29T13:32:54+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "用户编程接口"  # 文章标题
url:  "posts/cpp/interview/os/api"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## 库函数调用与系统调用有什么不同

库函数是语言或应用程序的一部分，它是高层的、完全运行在用户空间、为程序员提供调用真正的在幕后完成实际事务的系统调用接口。

而系统函数是内核提供给应用程序的接口，属于系统的一部分。简单说，函数库调用是语言或应用程序的一部分，而系统调用是操作系统的一部分。

库函数调用通常比行内展开的代码慢，因为它需要付出函数调用的开销。但系统调用比库函数调用还要慢很多，因为它需要把上下文环境切换到内核模式。

## 静态链接与动态链接有什么区别

静态链接是指把要调用的函数或者过程直接链接到可执行文件中，成为可执行文件的一部分。换句话说，函数和过程的代码就在程序的 .exe 文件中，该文件包含了运行时所需的全部代码。静态链接的缺点是：当多个程序都调用相同函数时，内存中就会存在这个函数的多个复制，这样就浪费了内存资源。

动态链接是相对于静态链接而言的。动态链接调用的函数代码并没有被复制到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（一些重定位信息）。仅当应用程序被装入内存开始运行时，在操作系统的管理下，才在应用程序与相应的动态链接库 (dynamic link library, dll) 之间建立链接关系。当要执行调用 .dll 文件中的函数时，根据链接产生的重定位信息，操作系统才转去执行 .dll 文件中相应的函数代码。

静态链接的执行程序能够在其他同类操作系统的机器上直接运行。

## 静态链接库与动态链接库有什么区别

静态链接库就是使用的 .lib 文件，库中的代码最后需要链接到可执行文件中去，所以静态链接的可执行文件一般比较大一些。

动态链接库是一个包含可由多个程序同时使用的代码和数据的库，它包含函数和数据的模块的集合。程序文件（如.exe 文件或.dll 文件）在运行时加载这些模块（即所需的模块映射到调用进程的地址空间）。

静态链接库和动态链接库的相同点是它们都实现了代码的共享，不同点是静态链接库 .lib 文件中的代码被包含在调用的 .exe 文件中，该 .lib 文件中不能再包含其他动态链接库或者静态链接库了。而动态链接库 .dll 文件可以被调用的 .exe 动态地“引用”和“卸载”，该 .dll 文件中可以包含其他动态链接库或者静态链接库。

## 用户态和核心态有什么区别

核心态与用户态是操作系统的两种运行级别，它用于区分不同程序的不同权利。

核心态就是拥有资源多的状态，或者说访问资源多的状态，也称为特权态。相对来说，用户态就是非特权态，在此种状态下访问的资源将受到限制。如果一个程序运行在特权态，则该程序就可以访问计算机的任何资源，即它的资源访问权限不受限制。如果一个程序运行在用户态，则其资源需求将受到各种限制。例如，如果要访问操作系统的内核数据结构，如进程表，则需要在特权态下才能办到。如果要访问用户程序里的数据，则在用户态下就可以了。

Intel CPU 提供 Ring0～Ring3 共 4 种级别的运行模式。Ring0 级别最高，Ring3 级别最低。

用户态：Ring3 运行于用户态的代码则要受到处理器的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段（TTS）中 I/O 许可位图（I/O Permission Bitmap）中规定的可访问端口进行直接访问。

核心态：Ring0 在处理器的存储保护中，核心态或者特权态（与之对应的是用户态）是操作系统内核所运行的模式。运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。

当一个任务（进程）执行系统调用而陷入内核代码中执行时，就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0 级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（或简称为用户态）。即此时处理器在特权级最低的（3 级）用户代码中运行。

在核心态下 CPU 可执行任何指令；在用户态下 CPU 只能执行非特权指令。当 CPU 处于核心态时，可以随意进入用户态；而当 CPU 处于用户态时，用户从用户态切换到核心态只有在系统调用和中断两种情况下发生。一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入核心态。

核心态和用户态各有优势：运行在核心态的程序可以访问的资源多，但可靠性、安全性要求高，维护管理都较复杂；用户态程序访问的资源受限，但可靠性、安全性要求低，自然编写维护起来都较简单。一个程序到底应该运行在核心态还是用户态取决于其对资源和效率的需求。

那么，什么样的功能应该在核心态下实现呢？首先，CPU 管理和内存管理都应该在核心态实现。这些功能可不可以在用户态下实现呢？当然能，但是不太安全。

诊断与测试程序也需要在核心态下实现，因为诊断和测试需要访问计算机的所有资源。输入输出管理也一样，因为要访问各种设备和底层数据结构，也必须在核心态实现。

对于文件系统来说，则可以一部分放在用户态，一部分放在核心态。文件系统本身的管理，即文件系统的宏数据部分的管理，必须放在核心态，不然任何人都可能破坏文件系统的结构；而用户数据的管理，则可以放在用户态。编译器、网络管理的部分功能、编辑器用户程序，自然都可以放在用户态下执行。

## 用户栈与内核栈有什么区别

内核在创建进程的时候，在创建 task_struct 的同时，会为进程创建相应的堆栈。每个进程会有两个栈：一个用户栈，存在于用户空间；一个内核栈，存在于内核空间。当进程在用户空间运行时，CPU 堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，CPU 堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。

当进程因为中断或者系统调用而从用户态转为内核态时，进程所使用的堆栈也要从用户栈转到内核栈。进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；当进程从内核态恢复到用户态时，把内核栈中保存的用户态的堆栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈和用户栈的互转。

那么，当从内核态转到用户态时，由于用户栈的地址是在陷入内核的时候保存在内核栈里面的，所以可以很容易地找到这个地址；但是在陷入内核的时候，如何知道内核栈的地址？关键在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为当进程在用户态运行时，使用的是用户栈，当进程陷入到内核态时，内核栈保存进程在内核态运行的相关信息，但是，一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核时得到的内核栈都是空的，所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。

```c++

```
