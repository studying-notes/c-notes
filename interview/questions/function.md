---
date: 2022-10-27T13:34:46+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "函数"  # 文章标题
url:  "posts/cpp/interview/questions/function"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## 怎么样写一个接受可变参数的函数

C 语言中支持函数调用的参数为变参形式。例如，`printf( )` 这个函数，它的函数原型是 `int printf( const char * format,...)`，它除了有一个参数 format 固定以外，后面跟的参数的个数和类型都是可变的，可以有以下多种不同的调用方法：

```c++
printf("%d", i);
printf("%s", s);
printf("the number is%d ,string is:%s", i, s);
```

printf() 函数是一个有着变参的库函数。在 C 语言中，程序员也可以根据实际需求编写变参函数。如下程序示例代码，实现了一个变参函数 add()，该函数可以实现多参数求和运算。

```c++
#include <cstdarg>
#include <iostream>

int add(int n, ...) {
  va_list ap;
  int sum = 0, i;
  va_start(ap, n);
  for (i = 0; i < n; i++) {
    sum += va_arg(ap, int);
  }
  va_end(ap);
  return sum;
}

int main() {
  std::cout << add(3, 1, 2, 3) << std::endl;
  return 0;
}
```

## 函数指针与指针函数有什么区别

### 指针函数

返回值为指针类型的函数，本质上是一个函数，**函数返回类型是某一类型的指针**。其形式如下：

类型标识符 *函数名(参数列表)

例如，`int *f(x,y)`，它的意思是声明一个函数 f(x,y)，该函数返回类型为 int 型的指针。

### 函数指针

指向函数的指针变量，即本质是一个指针变量，它**指向的是一个函数**。其形式如下：

类型说明符 (*函数名)(参数)

例如，`int (*pf)(int x)`，它的意思是声明一个函数指针，而 pf = func 则是将 func 函数的首地址赋值给指针变量 pf。

```c++
#include <iostream>

int add(int a, int b) {
  return a + b;
}

int minus(int a, int b) {
  return a - b;
}

// 定义一个指向函数指针的数组
int (*fn[])(int, int){
    add,
    minus,
};

int calculate(int op, int a, int b) {
  return fn[op](a, b);// 通过下标调用函数
}

int main() {
  int a = 1, b = 2;
  std::cout << calculate(0, a, b) << std::endl;
  std::cout << calculate(1, a, b) << std::endl;
  return 0;
}
```

## 数组指针/指针数组

### 数组指针

数组指针就是指向数组的指针，它表示的是一个指针，这个指针指向的是一个数组，它的重点是指针。

例如，`int (*pa)[8`] 声明了一个指针，该指针指向了一个有 8 个 int 型元素的数组。

```c++
#include <iostream>

int main() {
  int b[12] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
  int(*p)[4] = (int(*)[4])b;
  std::cout << **(++p) << std::endl;
  return 0;
}
```

上例中，p 是一个数组指针，它指向一个包含有 4 个 int 类型数组的指针，刚开始 p 被初始化为指向数组 b 的首地址，`++p` 相当于把 p 所指向的地址向后移动 4 个 int 所占用的空间，此时 p 指向数组 `{5,6,7,8}`，语句 `*(++p))` ;表示的是这个数组中第一个元素的地址，语句`**(++p))` ;会输出这个数组的第一个元素 5。

### 指针数组

指针数组表示的是一个数组，而数组中的元素是指针。

## 函数模板/模板函数

函数模板是对一批模样相同的函数的说明描述，它不是某一个具体的函数；而模板函数则是将函数模板内的“数据类型参数”具体化后得到的重载函数（就是由模板而来的函数）。简单地说，函数模板是抽象的，而模板函数是具体的。

函数模板的形式如下：

```c++
template <模板类型形参表>
<返回值类型> <函数名>(模板函数形参表) {
  // 函数体
}
```

其中，<模板函数形参表> 的类型可以是任何类型，包括基本数据类型和类类型。需要注意的是，函数模板并不是一个实实在在的函数，它是一组函数的描述，并不能直接执行，需要实例化为模板函数后才能执行，而一旦数据类型形参实例化以后，就会产生一个实实在在的模板函数了。

示例代码如下：

首先给出一个有 2 个参数的函数模板：

```c++
template<class T>
T max(T param1, T param2) {
  // return the larger of the two parameters
  return param1 > param2 ? param1 : param2;
}
```

根据上面已定义的模板，编译器将可能生成下面的多个不同的模板函数（函数模板的目的就是函数重载）：

```c++
int max(int param1, int param2);
double max(double param1, double param2);
float max(float param1, float param2);
```

> 不需要手动生成这些函数，编译器会自动生成。

```c++
int main() {
  std::cout << max(1, 4) << std::endl;
  std::cout << max(1.0, 4.0) << std::endl;
  std::cout << max('a', 'b') << std::endl;
  return 0;
}
```

## 类模板/模板类

类模板与函数模板类似，它将数据类型定义为参数，描述了代码类似的部分类的集合，具体化为模板类后，可以用于生成具体的对象。

类模板的形式如下：

```c++
template <模板类型形参表>
class <类名> {
  // 类体
};

template <模板类型形参表>
<返回值类型> <类名><类型名表>::<成员函数名>(模板函数形参表) {
  // 函数体
}
```

其中，<类型形参表>与函数模板中的<类型形参表>类似，而类模板本身不是一个真实的类，只是对类的一种描述，必须用类型参数将其实例化为模板类后，才能用来生成具体的对象。简言之，类是对象的抽象，而类模板就是类的抽象。

具体而言，C++ 中引入模板类主要有以下 5 个方面的好处：

1. 可用来创建动态增长和减小的数据结构。

2. 它是类型无关的，因此具有很高的可复用性。

3. 它在编译时而不是运行时检查数据类型，保证了类型安全。

4. 它是与平台无关的，可移植性强。

5. 可用于基本数据类型。

## 指针常量/常量指针

### 指针常量

指针常量是指定义的指针只能在定义的时候初始化，之后不能改变其值。其格式为

```c++
[数据类型] [*] [const] [指针常量名称]
```

```c++
char*const p1;
int*const p2;
```

const 位于指针声明符“*”的右侧，这说明声明的对象是一个常量，而对象的数据类型是指针。所以第一句定义了一个只读的字符型指针 p1，第二句定义了一个只读的整型指针 p2。常指针的值不能改变，但是其指向的内容却可以改变。如下例所示：

```c++
#include <iostream>

int main() {
  char a[5] = "abcd";
  char b[5] = "efgh";
  char *const p1 = a;
  char *const p2 = b;
  std::cout << "Before Change" << std::endl;
  std::cout << "a: " << a << std::endl;
  std::cout << "b: " << b << std::endl;

  *p1 = '1';
  b[0] = '2';
  //  p1 = p2;//error: assignment of read-only variable ‘p1’

  std::cout << "After Change" << std::endl;
  std::cout << "a: " << a << std::endl;
  std::cout << "b: " << b << std::endl;

  return 0;
}
```

指针指向的内存地址不能更改，指针的值只能在定义的时候初始化，其他地方不能更改。

### 常量指针

常量指针是指向常量的指针，因为常量指针指向的对象是常量，因此这个对象的值是不能够改变的。

需要注意的是，指针常量强调的是指针不可改变性，而常量指针强调的是指针对其所指对象的不可改变性，它指向的对象的值是不能通过常量指针改变的，但并不是说也不能通过其他方式来修改。

定义的格式如下：

```c++
[数据类型] [const] [*] [常量指针名称];
[const] [数据类型] [*] [常量指针名称];
```

```c++
int const *p2;
const char *p1;
```

```c++
#include <iostream>

int main() {
  char a[5] = "abcd";
  char b[5] = "efgh";
  const char *p1 = a;
  const char *p2 = b;
  std::cout << "Before Change" << std::endl;
  std::cout << "a: " << a << std::endl;
  std::cout << "b: " << b << std::endl;
  std::cout << "p1: " << p1 << std::endl;
  std::cout << "p2: " << p2 << std::endl;

  //  *p1 = '1'; // This is not allowed
  b[0] = '2';
  p1 = p2;

  std::cout << "After Change" << std::endl;
  std::cout << "a: " << a << std::endl;
  std::cout << "b: " << b << std::endl;
  std::cout << "p1: " << p1 << std::endl;
  std::cout << "p2: " << p2 << std::endl;

  return 0;
}
```

```
Before Change
a: abcd
b: efgh
p1: abcd
p2: efgh
After Change
a: abcd
b: 2fgh
p1: 2fgh
p2: 2fgh
```

## C++ 函数传递参数的方式有哪些

当进行函数调用时，要填入与函数形式参数个数相同的实际参数，在程序运行过程中，实际参数（简称实参）就会将参数值传递给相应的形式参数（简称形参），然后在函数中实现对数据的处理和返回。C++函数传递参数的方式一般有以下4种。

### 值传递

进行值传递时，就是将实参的值复制到形参中，而形参和实参不是同一个存储单元，所以在函数调用结束后，实参的值不会发生改变。

```c++
#include <iostream>

void swap(int a, int b) {
  a ^= b;
  b ^= a;
  a ^= b;
  std::cout << "a = " << a << ", b = " << b << std::endl;
}

int main() {
  int a = 5;
  int b = 10;
  swap(a, b);
  std::cout << "a = " << a << ", b = " << b << std::endl;
  return 0;
}
```

也就是说，进行函数调用的时候只交换了形参的值，而并未交换实参的值，形参值的改变并没有改变实参的值。

### 指针传递

进行指针传递时，形参是指针变量，实参是一个变量的地址，调用函数时，形参（指针变量）指向实参变量单元。这种方式其实还是“值传递”，只不过实参的值是变量的地址而已。在函数中改变的不是实参的值，而是实参地址所指向的变量的值。

```c++
#include <iostream>

void swap(int *a, int *b) {
  *a ^= *b;
  *b ^= *a;
  *a ^= *b;
  std::cout << "a = " << *a << ", b = " << *b << std::endl;
}

int main() {
  int a = 5;
  int b = 10;
  swap(&a, &b);
  std::cout << "a = " << a << ", b = " << b << std::endl;
  return 0;
}
```

通过指针传递的方式可以修改实参的值，因为传递的是实参的地址，可以在函数中通过这个地址来间接地修改实参的值。但是，从本质上讲，指针传递也是值传递，只不过传递的是地址而已，因此也满足值传递的特性。也就是说，在函数体内修改 a 和 b 的值，而不是 `*a` 和 `*b` 的值的时候，这个修改对实参是不可见的。

### 引用传递

被调函数的形参虽然也作为局部变量在被调函数的栈中开辟了内存空间，但是这时存放的是由主调函数传递进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，也就是说通过栈中存放的地址来访问主调函数中的实参变量。所以，被调函数对形参做的任何操作对实参变量都可见。与指针传递不同的是，使用指针传递的时候，在函数体内可以直接修改这个地址的值，而使用引用传递是无法做到这一点的。

```c++
#include <iostream>

void swap(int &a, int &b) {
  a ^= b;
  b ^= a;
  a ^= b;
  std::cout << "a = " << a << ", b = " << b << std::endl;
}

int main() {
  int a = 5;
  int b = 10;
  swap(a, b);
  std::cout << "a = " << a << ", b = " << b << std::endl;
  return 0;
}
```

### 全局变量传递

这里的“全局”变量并一定是真正的全局（所有代码都可以直接访问），只要这个变量的作用域足够这两个函数访问就可以了，例如一个类中的两个成员函数可以使用一个成员变量实现参数传递，或者使用 static 关键字定义，或者使用 namespace（命名空间）进行限制等，而这里的成员变量在这种意义上就可以称为“全局”变量。当然，可以使用一个类外的真正的全局变量来实现参数传递，但有时并没有必要，从工程上讲，作用域越小越好。

全局变量传递的优点是效率高，但它对多线程的支持不好，如果两个进程同时调用同一个函数，而通过全局变量进行传递参数，该函数就不能总是得到想要的结果。

## 重载与覆盖有什么区别

### 重载

重载是函数名字相同，函数参数不同（参数的类型、个数、顺序不同）。在同一可访问区域内声明的几个具有不同参数列表的同名函数，程序会根据不同的参数列来确定具体调用哪个函数。对于重载函数的调用，在编译期间就已经确定了，是静态的，它们的地址在编译期间就绑定了，与多态无关。注意，重载不关心函数的返回值类型，因此也就无法通过函数的返回值进行重载。

首先看一下以下 7 个函数的声明：

1. double calculate(double) ;

2. double calculate(double，double) ;

3. double calculate(double, int) ;

4. double calculate(int, double) ;

5. double calculate(int) ;

6. float calculate(float) ;

7. float calculate(double) ;

7 个同名函数 calculate，1-6 中任两个均构成重载，6 和 7 也能构成重载，而 1 和 7 却不能构成重载，因为 1 和 7 的参数相同。

成员函数被重载的特征如下：

1. 相同的范围（在同一个类中）。

2. 函数名字相同。

3. 参数列表不同。

4. virtual 关键字可有可无。

### 覆盖

覆盖是指派生类中存在重新定义基类的函数，其函数名、参数列表、返回值类型必须同父类中的相对应被覆盖的函数严格一致，覆盖函数和被覆盖函数只有函数体不同，当派生类对象调用子类中该同名函数时，会自动调用子类中的覆盖版本，而不是父类中的被覆盖函数版本，它和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的。

覆盖的特征如下：

1. 不同的范围（分别位于派生类与基类）。

2. 函数名字相同。

3. 参数相同。

4. 基类函数必须有 virtual 关键字。

### 重载与覆盖的区别

1. 覆盖是子类和父类之间的关系，是垂直关系；重载是同一个类中函数之间的关系，是水平关系。

2. 覆盖只能由一个函数，或只能由一对函数产生关系；函数的重载是多个函数之间的关系。

3. 覆盖要求参数列表相同；重载要求参数列表不同。

4. 覆盖关系中，调用哪个函数是根据对象的类型（对象对应存储空间类型）决定的，重载关系是根据调用时的实参表与形参表来选择方法体的。

5. 覆盖是运行时确定的，而重载是编译时确定的。

```c++
#include <iostream>

class Base {
public:
  void f(int x) {
    std::cout << "Base::f(int)" << std::endl;
  }

  void f(double x) {
    std::cout << "Base::f(double)" << std::endl;
  }

  virtual void g() {
    std::cout << "Base::g(void)" << std::endl;
  }
};

class Derived : public Base {
public:
  void g() {
    std::cout << "Derived::g(void)" << std::endl;
  }
};

int main() {
  Derived d;
  Base *b = &d;
  b->f(1);
  b->f(1.0);
  b->g();
  return 0;
}
```

```
Base::f(int)
Base::f(double)
Derived::g(void)
```

### 隐藏

隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：

1. 如果派生类的函数与基类的函数同名，但是参数不同，则不论有无 virtual 关键字，基类的函数在子类中都将被隐藏。

2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字，此时基类的函数在子类中也被隐藏。

调用一个类的成员函数时，编译器会沿着类的继承链逐级向上查找函数的定义，如果找到了，就停止查找。

回到隐藏的定义中，前面已经说了有 virtual 关键字，并且派生类函数与基类函数同名，同参数函数构成覆盖的关系，因此隐藏的关系只有如下几种可能：

1. 必须分别位于派生类和基类中。

2. 必须同名。

3. 参数不同的时候本身已经不能构成覆盖关系了，所以此时是否为 virtual 函数已经不重要了。

当参数相同的时候，就要看是否有 virtual 关键字，如果有，就是覆盖关系；如果没有，就是隐藏关系。

## 无参数构造函数是否可以调用单参数构造函数

无参数构造函数可以调用单参数的构造函数，但是，这种调用方法只是被当作一个普通的函数调用，同直接使用单参数的构造函数构来实例化一个对象是有区别的。

```c++
#include <iostream>

class A {
public:
  A() {
    A(10);
    Print();
  }
  A(int j) : i(j) {
    std::cout << "Call A(int j)" << std::endl;
  }
  void Print() {
    std::cout << "Call Print()" << std::endl;
  }
  int i;
};

int main() {
  A a;
  std::cout << a.i << std::endl;
  return 0;
}
```

```
Call A(int j)
Call Print()
0
```

以上代码希望无参数的构造函数调用带参构造函数，但未能实现。因为在无参数的构造函数内部调用带参的构造函数属用户行为，而非编译器行为，它只执行函数调用，而**不会执行其后的初始化表达式**。只有在通过构造函数实例化对象时，初始化表达式才会随相应的构造函数一起调用。

## C++ 中函数调用有哪几种方式

在 Win32 下有以下 4 种调用：

1. _cdecl。它是 C/C++ 的默认调用方式。实参是以参数列表从右依次向左入栈，出栈相反，函数堆栈由调用方来释放，主要用在那些带有可变参数的函数上，对于传送参数的内存栈是由调用者来维护的。另外，在函数名修饰约定方面也有所不同。由于每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用 _stdcall 函数的大。

2.  _stdcall。它是 WIN_API 的调用约定。其实，COM 接口等只要是声明定义接口都要显式指定其调用约定为 _stdcall。实参以参数列表从右依次向左入栈，出栈相反。函数堆栈是由被调用方自己释放的。但是，若函数含有可变参数，那么即使显式指定了 _stdcall，编译器也会自动把其改变成 _cdecl。

3. _thiscall。它是类的非静态成员函数默认的调用约定，其不能用在含有可变参数的函数上，否则编译会出错。实参以参数列表从右依次向左入栈，出栈相反。函数堆栈是由被调用方自己释放的。但是，类的非静态成员函数内部都隐含有一个 this 指针，该指针不是存放在函数堆栈上的，而是直接存放在 CPU 寄存器上的。

4. _fastcall。快速调用。它们的实参并不是存放在函数堆栈上，而是直接存放在 CPU 寄存器上，所以不存在入栈、出栈、函数堆栈释放。

## 什么是可重入函数？ C 语言中如何写可重入函数

可重入函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，由操作系统调度去执行另外一段代码，而返回控制时不会出现什么错误而且每次运行都能得到正确的结果（对于相同的输入，每次都能得到相同的输出），可重入函数主要用于多任务环境中；而不可重入函数由于使用了一些系统资源，比如全局变量区、中断向量表等，所以它如果被中断，可能会出现问题（被中断后，其他进程有可能会修改这些全局变量，从而导致函数在每次运行都可能会得到不同的返回值），这类函数是不能运行在多任务环境下的。

满足下列条件的函数多数是不可重入的：

1. 函数体内使用了静态的数据结构或者全局变量。

2. 函数体内调用了 malloc() 或者 free() 函数。

3. 函数体内调用了标准 I/O 函数。

那么，如何才能写出可重入的函数呢？在函数体内不访问那些全局变量，不使用静态局部变量，坚持只使用缺省态 (auto) 局部变量，写出的函数就将是可重入的。如果必须访问全局变量，必须使用互斥信号量来保护全局变量。和硬件交互的时候关中断，当完成交换后，再开中断。

```c++

```
