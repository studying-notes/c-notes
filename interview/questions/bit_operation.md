---
date: 2022-10-26T14:51:20+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "位运算"  # 文章标题
url:  "posts/cpp/interview/questions/bit_operation"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## 一些结构声明中的冒号和数字是什么意思

C 语言的结构体可以实现位段（也称位域），它的定义形式是在一个定义的结构体成员后加上冒号，然后是该成员所占的位数。位段的结构体成员必须是 int 或者 unsigned int 类型，不能是其他类型。位段在内存中的存储方式是由具体的编译器决定的。

首先，定义位段的长度不能大于存储单元的长度。存储单元是指该位段的类型大小。其次，一个位段如果不能放在一个存储单元里，那么它会把这个存储单元中剩余的空间闲置，而从下一个存储单元开始存储下一个位段，即一个位段不能跨越两个存储单元，位段在一个存储单元中的存储是紧凑的。再次，位段名缺省时称作无名位段，无名位段的存储空间通常不用，而位段长度为 0 位表示下一个位段存储在一个新的存储单元中，位段长度为 0 的时候位段名必须缺省（不能定义位段名）。最后，一个结构体中既可以定义位段成员，也可以同时定义一般的结构体成员。这个时候，一般成员不和位段存储在同一个存储单元中。

```c++
#include <iostream>

typedef struct  {
  int a : 2;
  int b : 2;
  int c : 1;
}test;

int main() {
  test t;

  t.a = 1;
  t.b = 3;
  t.c = 1;

  std::cout << t.a << std::endl;
  std::cout << t.b << std::endl;
  std::cout << t.c << std::endl;

  return 0;
}
```

```
1
-1
-1
```

由于 a 占两位，而 a 被赋值为 1，二进制就是 01，因此，%d 输出的时候输出 1 ； b 也占两位，赋值为 3，二进制也就是 11，由于使用了 %d 输出，表示的是将这个 b 作为有符号 int 型来输出，这样的话二进制的 11 将会有一位被认为是符号位，并且两位的 b 也会被扩展为 int 类型，也就是 4 字节，即 32 位。其实，a 也做了这种扩展，只是扩展符号位的时候，由于数字在计算机中存储都是补码形式，因此扩展符号位的时候正数用 0 填充高位，负数用 1 填充高位。因此，对于 a 来说，输出的时候被扩展为 00000000 00000000 00000000 00000001，也就是 1，而 b 则扩展为 11111111 11111111 11111111 11111111，也就是 -1。同理，t.c 的输出也是 -1。

## 最有效的计算 2 乘以 8 的方法是什么

```c++
2<<3
```

虽然直接进行乘法操作符运算也可以进行 2 与 8 的相乘，但是该种方法并非最优，通过移位方法会比较高效。因为**将一个数左移 n 位，相当于乘以了 2 的 n 次方**。因此，一个数乘以 8，而 8 是 2 的 3 次方，所以只要将该数左移 3 位即可实现乘以 8 的目的。

常规的乘法运算也可以实现，但 CPU 直接支持位运算，效率最高，所以，操作 2 乘以 8 的最有效的方法是 2<<3。

## 如何使用位操作求两个数的平均值

一般而言，求解平均数的方法就是将两者相加，然后除以 2。以变量 x 与 y 为例，两者的平均数为 `(x+y)/2`。

但是采用上述方法，会存在一个问题，当两个数比较大时，如两者的和大于了机器位数能够表示的最大值，可能会存在数据溢出的情况，而采用位运算方法则可以避免这一问题，`(x&y)+((x^y)>>1)` 方式表达的意思都是求解变量 x 与 y 的平均数，而且位运算相比除法运算，效率更高。

对于表达式 `(x&y)+((x^y)>>1)`，x&y 表示的是取出 x 与 y 二进制位数中都为 '1' 的所有位， **x^y 表示的是 x 与 y 中有一个为 '1' 的所有位**，右移 1 位相当于执行除以 2 运算。整个表达式实际上可以分为两部分，第一部分是都为 '1' 的部分，求平均数后这部分的值保持不变；而第二部分是 x 为 '1'、y 为 '0' 的部分，以及 y 为 '1'、x 为 '0' 的部分，两部分加起来再除以 2，然后跟前面的相加就可以表示两者的平均数了。

## 如何利用位运算计算数的绝对值

以 x 为负数为例来分析。因为在计算机中，数字都是以补码的形式存放的，求负数的绝对值，应该是不管符号位，执行末位减 1 操作，按位取反即可。

对于一个负数，将其右移 31 位后会变成 0xffffffff (-1)，而取反就是与 0xffffffff (-1) 进行异或。因为任何数与 -1 异或，其实质都是把 x 的 0 和 1 进行颠倒计算，也就是取反。

而对于一个正数而言，右移31位则为 0x00000000。

如果用变量 y 表示 x 右移 31 位，`(x^y)-y` 则表示的是 x 的绝对值。

```c++
#include <iostream>

int abs(int x) {
  int y = x >> 31;
   return (x + y) ^ y;
//   return (x ^ y) - y;
}

int main() {
  std::cout << abs(-1) << std::endl;
  std::cout << abs(1) << std::endl;

  return 0;
}
```

## 如何求解整型数的二进制表示中 1 的个数

求解整型数的二进制表示中 1 的个数有以下两种方法：

方法一，判断每个数的二进制表示中每一位是否为 1，如果为 1，就在 count 上加 1，而循环的次数是常数，即 n 的位数。程序示例如下：

```c++
#include <iostream>

unsigned int func(unsigned int n) {
  unsigned int count = 0;
  while (n) {
    count += n & 0x1u;
    n >>= 1;
  }
  return count;
}

int main() {
  std::cout << func(9999) << std::endl;
  return 0;
}
```

但该方法有一个缺陷，就是在1比较稀疏的时候效率比较低。下面给出另外一种比较高效的方法。

方法二，程序代码如下：

```c++
#include <iostream>

unsigned int func(unsigned int n) {
  unsigned int count = 0;
  while (n) {
    n &= (n - 1);
    count++;
  }
  return count;
}

int main() {
  std::cout << func(9999) << std::endl;
  return 0;
}
```

在上例中，函数 func( ) 的功能是将 x 转化为二进制数，然后计算该二进制数中含有的 1 的个数。首先以 9 为例来分析，9 的二进制表示为 1001，8 的二进制表示为 1000，两者执行&操作之后结果为 1000，此时 1000 再与 0111（7 的二进制位）执行&操作之后结果为 0。

为了理解这个算法的核心，需要理解以下两个操作：

1. 当一个数被减 1 时，它最右边的那个值为 1 的 bit 将变为 0，同时其右边的所有的 bit 都会变成 1。

2. 每次执行 x & (x-1) 的作用是把 x 对应的二进制数中的最后一位 1 去掉。因此，循环执行这个操作直到 x 等于 0 的时候，循环的次数就是 x 对应的二进制数中 1 的个数。

## 嵌入式编程中，什么是大端？什么是小端

采用小端模式的 CPU 对操作数的存放方式是从低字节到高字节，而大端模式对操作数的存放方式是从高字节到低字节。

## 如何判断计算机处理器是大端，还是小端

联合体方式：

```c++
int endian_mode() {
  union {
    int i;
    char c[sizeof(int)];
  } u;
  u.i = 1;
  return (u.c[0] == 1);
}
```

指针方式：

```c++
#include <iostream>

int endian_mode() {
  int i = 1;
  char *p = (char *) &i;
  return (int) *p;
}

int main() {
  if (endian_mode() == 1) {
    std::cout << "Little endian" << std::endl;
  } else {
    std::cout << "Big endian" << std::endl;
  }

  return 0;
}
```

## 考虑 n 位二进制数，有多少个数中不存在两个相邻的 1

当 n = 1 时，满足条件的二进制数为 0、1，一共两个数；当 n = 2 时，满足条件的二进制数有 00、01、10，一共 3 个数；当 n = 3 时，满足条件的二进制数有 000、001、010、100、101，一共 5 个数。

对 n 位二进制数，设所求结果为 a(n)，对于第 n 位的值，分为 0 或者 1 两种情况：

1. 第 n 位为 0，则有 a(n-1) 个数。

2. 第 n 位为 1，则要满足没有两个相邻为 1 的条件，第 n-1 位为 0，有 a(n-2) 个数，因此得到结论 a(n) = a(n-1)+a(n-2)。

通过观察 2 中的表达式可以发现，式子满足斐波拉契数列的特点，因此可以用递归的方式来实现。

```c++
#include <iostream>

int fib(int n) {
  if (n == 0)
    return 0;
  if (n == 1)
    return 1;
  return fib(n - 1) + fib(n - 2);
}

int main() {
  for (int i = 1; i < 10; ++i) {
    std::cout << i << "=" << fib(i + 2) << std::endl;
  }
  return 0;
}
```

```
1=2
2=3
3=5
4=8
5=13
6=21
7=34
8=55
9=89
```

## 不用除法操作符如何实现两个正整数的除法

可以根据除法运算的原理进行减法操作，对除数循环减被除数，减一次结果加一，直到刚好减为 0 或余数小于被除数为止。

如果每次采用将比较数翻倍的比较方法，则算法效率能够得到极大优化。这种算法的主要思路为：首先用 3 与 100 比较，显然 3 小于 100，然后翻倍 6，仍然小于 100，以此类推用 12, 24, 48, 96, 192 与 100 进行比较，由于 192>100，因此退回到 96。

```c++
#include <iostream>

int divide(const int x, const int y) {
  int remainder = x;
  int quotient = 0;

  while (remainder >= y) {
    int m = 1;
    while (y * m <= remainder >> 1) {
      m <<= 1;
    }
    quotient += m;
    remainder -= y * m;
  }

  return quotient;
}

int main() {
  std::cout << divide(15, 3) << std::endl;
  return 0;
}
```

## 位运算实现四则运算

1. 取相反数：`-n = ～(n-1) = ～n+1`。

2. 获取整数 n 的二进制中最后一个 1：`n & (-n)` 或者 `n & ～(n-1)`。例如，n = 010100，则 -n = 101100，n & (-n) = 000100。

3. 去掉整数 n 的二进制中最后一个 1：`n & (n-1)` ，如 n = 010100 ， n-1 = 010011 ， n & (n-1) = 010000。

### 加法

```c++
int add(int x, int y) {
  int sum = x ^ y;
  int carry = x & y;
  return carry ? add(sum, carry << 1) : sum;
}
```

### 减法

```c++
int subtract(int x, int y) {
  //  return add(x, ~(y - 1));
  return add(x, ~y + 1);
}
```

### 乘法

首先必须要判断乘数的正负，将乘数转换为正数。

例如 `1011*1010`，因为二进制运算的特殊性，所以可以将该乘法运算表达式拆分为两个运算，`1011*0010` 与 `1011*1000` 的和，而对于二进制的运算，左移 1 位，等价于乘以 0010，左移 3 位，等价于乘以 1000，所以，两者的乘积为 10110 与 1011000 的和，即为 1101110。

因而乘法可以通过一系列移位和加法完成。

```c++
int multiply(int x, int y) {
  bool negative = false;

  if (y < 0) {
    negative = true;
    y = add(~y, 1);
  }

  int sum = 0;

  while (y) {
    if (y & 1) {
      sum = add(sum, x);
    }
    x <<= 1;
    y >>= 1;
  }

  return negative ? add(~sum, 1) : sum;
}
```

或者提前计算一个 map，对值和移动的位数进行映射。最后一个 1 可通过 `b&～(b-1)` 求得，可通过`b&(b-1)` 去掉。

```c++
  std::map<int, int> bit_map;
  for (int i = 0; i < 32; i++) {
    bit_map.insert(std::pair<int, int>(1 << i, i));
  }

  while (y > 0) {
    int last_bit = bit_map[y & ~(y - 1)];
    sum += (x << last_bit);
        y &= y - 1;
  }
```

```c++

```
