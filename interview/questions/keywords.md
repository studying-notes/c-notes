---
date: 2022-10-24T14:53:59+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "C/C++关键字相关问题"  # 文章标题
url:  "posts/cpp/interview/questions/keywords"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## static 静态变量有什么作用

在 C 语言中，关键字 static 的意思是静态，它主要有如下两个作用：

1. 在函数体内，静态变量具有“记忆”功能，即一个被声明为静态的变量只会被初始化一次，然后在这一函数被调用的过程中其值维持不变。

2. 在文件内但在函数体外，用来限制变量或函数的作用域为当前文件，即如果一个变量被声明为静态的，那么该变量可以被当前文件内所有函数访问，但不能被其他文件中的函数访问。它是**一个本地的全局变量，且只会被初始化一次**。如果一个函数被声明为静态的，那么该函数与普通函数作用域不同，其作用域仅在本文件中，它只可被当前文件内的其他函数调用，不能被其他文件的函数调用。也就是说，这个函数被限制在仅能被声明它的文件内使用。

在 C++ 语言中，除了以上功能外，在类内数据成员的也可以被定义为 static，在这种情况下，该数据成员就是类的静态数据成员。静态数据成员有以下特点：

1. 对于非静态数据成员而言，每个对象都有自己单独的一个副本。而**静态数据成员被当作是类的成员，只会存在唯一的副本，且被所有对象共享**。

2. **静态成员变量属于类而不属于对象**。也就是说，即使没有实例化的对象，也可以使用静态变量，通常通过“类名:静态成员变量”来访问。

3. 静态数据成员和普通数据成员一样遵从 public、protected、private 访问规则。

4. static 成员变量的初始化是在类外，初始化的时候不需要再使用 static 关键字。被 private 或 protected 修饰的 static 成员虽然可以在类外初始化，但是不能在类外被访问。下例给出 static 成员变量的初始化以及使用的方法：

```c++
#include <iostream>

class Student {
private:
  static int age;

public:
  static int height;
};

// 可以在类外初始化静态成员变量
int Student::age = 19;
int Student::height = 167;

int main() {
  // 无法直接访问私有静态成员变量
  //    std::cout << Student::age << std::endl;

  // 可以通过类名访问公有静态成员变量
  std::cout << Student::height << std::endl;

  // 也可以通过对象访问公有静态成员变量
  Student s;
  std::cout << s.height << std::endl;

  return 0;
}
```

5. 在类中，被 static 修饰的函数是类的静态成员函数，静态成员函数也属于类，而不属于某一个特定对象，被所有对象共享。普通成员函数一般都隐含了一个 this 指针，this 指针指向类的对象本身，例如，可以通过 this->fn( ) 来调用普通成员函数 fn( )。但是，由于静态成员函数属于类，而不属于对象，因此它没有 this 指针。从这个意义上讲，类的静态成员函数无法访问对象成员，也无法访问普通成员函数，它只能访问静态成员函数或静态成员。也就是说，静态成员函数不能直接或间接地访问非 static 函数或成员变量。

与全局变量相比，使用静态数据成员有以下两个优势：

1. 全局变量的作用范围是整个工程，而 static 变量的作用范围仅仅是这个变量所在的文件。static 变量与全局变量相比，减少了命名冲突的可能性。可以在不同的文件中定义名字相同的 static 变量，但是不能定义名字相同的全局变量。

2. 可以实现信息隐藏。静态数据成员可以是 private 成员，而全局变量不能。

需要注意的是，类的静态成员必须被初始化，而且必须在类外面初始化。

上例中的语句 `static int age;` 只是一个声明，类中的静态成员变量仅仅是声明，而变量被声明的时候不分配存储空间，只有在定义的时候才分配空间（`int Student::age = 19` 定义并初始化了静态变量 age），变量的声明可以被理解为一个承诺，它承诺这个变量将会在某个地方被定义。

由此可见，为了使用这个静态变量，必须初始化（定义）这个静态变量，为什么静态变量不能在类内部初始化呢？由于类的声明可能会被多个地方引用，如果把静态变量的初始化放在类内部，每次引用都会初始化一次（分配一次空间），这与静态变量只能初始化一次且只存在一个副本相冲突，因此，静态变量只能在类外面初始化。

## 在 C 语言中，为什么 static 变量只初始化一次

对于所有的对象（不仅仅是静态对象），初始化都只有一次，而由于静态变量具有“记忆”功能，初始化后，一直都没有被销毁，都会保存在内存区域中，所以不会再次初始化。

存放在静态区的变量的生命周期一般比较长，它与整个程序“同生死、共存亡”，所以它只需初始化一次。而 auto 变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁。

```c++
#include <iostream>

void fun(int i) {
  // 只有在第一次调用的时候，这一行初始化代码才会执行
  static int value = 0;
  value += i;
  std::cout << value << std::endl;
}

int main() {
  fun(0);
  fun(1);
  fun(2);

  return 0;
}
```

```
0
1
3
```

第一次调用 fun(0) 的时候，value 被初始化为 0，执行 value+ = i 后，value 的值还是 0 ；接着在调用 f(1) 的时候，由于 value 是 static 变量，因此初始化语句 static int value = 0 不再被执行，而直接执行 value+ = i。由于此时 value = 0，i = 1，执行结束后，value 的值变为 1。最后在调用 f(2) 的时候，value = 1，i = 2，因此执行结束后，value 的值变为 3。

## 在头文件中定义静态变量是否可行，为什么

可行，但不推荐在头文件中定义任何变量，当然也包括静态变量。

如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误。因为如果在使用了该头文件的每个 C 语言文件中定义静态变量，按照编译的步骤，在每个头文件中都会单独存在一个静态变量，从而会引起空间浪费或者程序错误。

## const 有哪些作用

常类型也称为 const 类型，是指使用类型修饰符 const 修饰的变量或对象。const 是 C 和 C++ 中常见的关键字。

在 C 语言中，它主要有如下作用：

1. 定义变量（局部变量或全局变量）为常量。

2. 修饰函数的参数，表示在函数体内不能修改这个参数的值。

3. 修饰函数的返回值。

   1. 如果给用 const 修饰返回值的类型为指针，那么函数返回值（即指针）的内容是不能被修改的，而且这个返回值只能赋给被 const 修饰的指针。

   2. 如果用 const 修饰的返回值为引用，那么这个函数调用表达式不能被作为左值使用。

   3. 如果用 const 修饰普通的返回值，如返回 int 变量，由于这个返回值是一个临时变量，在函数调用结束后这个临时变量的生命周期也就结束了，因此把这些返回值修饰为 const 是没有意义的。

除此之外，在 C++ 语言中，const 还有下面两种常见的用法：

1. const 修饰类的数据成员。表示这个数据成员只在某个对象生存期内是常量，而对于整个类而言，却是可变的。因为一个类可以创建多个对象，不同的对象其 const 数据成员可以有不同的值。正因为如此，const 数据成员不能在类声明中初始化。

2. const 修饰类的成员函数。那么这个函数就不能修改对象的成员变量。

具体而言，const 的优点如下所示：

1. 进行类型检查，使编译器对处理内容有更多的了解，消除了一些隐患。
2. 避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。同宏定义一样，可以做到不变则已，一变都变。例如，可以定义一个常量 `const int MAX = 10`，如果想修改 MAX 的内容，只需要在定义的地方修改 `const int MAX =期望值`即可，而不需要在各个被用到的地方都修改。
3. 保护被修饰的东西，防止被意外修改，增强了程序的健壮性。
4. 为函数重载提供参考。
5. 节省空间，避免不必要的内存分配。从汇编的角度看，const 定义常量只是给出了对应的内存地址，而不是像 `#define` 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一个复制品，而 `#define` 定义的常量在内存中有若干个复制品。
6. 提高了程序的效率。编译器通常不为普通 const 常量分配存储空间，而是将它们**保存在符号表**中，这使得它成为一个**编译期间的常量**，没有了存储与读内存的操作，它的效率也很高。

## 什么情况下需要使用 const 关键字

### 修饰一般常量

一般常量是指简单类型的常量。这种常量在定义时，修饰符 const 可以用在类型说明符前，也可以用在类型说明符后。例如：int const x = 2 或 const int x = 2。

### 修饰常数组

定义或说明一个常数组可以采用如下格式：

```c++
int const a[8]={1, 2, 3, 4, 5, 6, 7, 8};
const int a[8]={1, 2, 3, 4, 5, 6, 7, 8};
```

### 修饰常对象

常对象是指对象常量，定义格式如下：

```c++
class A;
const A a;
A const a;
```

定义常对象时，同样要进行初始化，并且该对象不能再被更新。修饰符 const 可以放在类名后面，也可以放在类名前面。

### 修饰常指针

```c++
const int*p;// const 修饰 int，说明 p 可变，p 指向的 int 变量的值可变
int const*p;// const 修饰 *p（*p 也是 int 变量）。p 可变，p 指向的 int 变量的值可变
int* const p;// const 修饰指针 p，p 不可变，p 指向的对象可变
const int* const p;// 指针 p 和 p 指向的对象都不可变
```

### 修饰常引用

被 const 修饰的引用变量为常引用，一旦被初始化，就不能再指向其他对象了。

### 修饰函数的常参数

const 修饰符也可以修饰函数的传递参数，格式如下：

```c++
void Fun(const int Var);
```

告诉编译器 Var 在函数体中不能被改变，从而防止了使用者一些无意的或错误的修改。

### 修饰函数的返回值

const 修饰符也可以修饰函数的返回值，表明该返回值不可被改变，格式如下：

```c++
const int Fun1( );
const MyClass Fun2( );
```

下面两种写法有区别吗？

```c++
int GetInt(void)
const int GetInt(void)
```

如果是下面的呢？其中 A 为用户自定义的数据类型。

```c++
A GetA(void)
const A GetA(void)
```

没有任何区别。

1. 如果函数使用“值传递”方式返回一个值，在这种情况下，函数会把返回值复制到外部临时的存储单元中，那么添加 const 修饰没有任何价值。因此，对于“值传递”来说，添加 const 没有太大意义。因此，题目中的这两种写法是没有本质区别的。

2. 当返回值为被 const 修饰的指针时，返回值也必须赋值给 const 类型的指针，因为指针指向的数据是常量，是不能被修改的。如下例所示：

```c++
#include <iostream>

const int *f() {
  int *a = new int(2);
  return a;
}

int main() {
  //int *a = f();  // error: cannot convert ‘const int*’ to ‘int*’ in assignment
  const int *a = f();
  return 0;
}
```

3. 当返回值为引用的时候，用 const 修饰返回值与不用 const 修饰返回值其使用场景也有所不同。如下例所示：

```c++
const A&operator*(const A&l, const A&r);
```

如果这个函数的返回值不是 const，那么下面的写法也是合法的：

```c++
A a, b, c;
(a*b)=c;
```

一般来讲，这种写法是不应该被允许的（例如，对于语句 `int a,b,c`；，类似于 `a*b=c` 这样的写法也是不允许的）。为了跟普通类型的运算保持一致，有必要避免 `(a*b)=c` 这种写法，避免的方法是把函数的返回值修饰为 const。

### 修饰类的成员函数

const 修饰符也可以修饰类的成员函数，表示不能修改类或对象的属性。

### 在另一连接文件中引用 const 常量

```c++
extern const int i;
extern const int j=10;
```

第一种用法是正确的，第二种用法是错误的，因为常量不可以被再次赋值。另外，还要注意，常量必须初始化，例如 `const int i = 5`。

## 常引用与普通引用有什么区别

一般引用的初始化表达式必须是左值，而常引用的初始化表达式可以是右值。如下例所示：

```c++
int main() {
  int n = 6;
  int &nRef = n;
  const int &nCRef = n;
  //int &iRef = 10; // error: cannot bind non-const lvalue reference of type ‘int&’ to an rvalue of type ‘int’
  const int &iCRef = 10;// ok

  return 0;
}
```

## C++ 与 C 的编译器在处理 const 的时候有什么不同

C++ 中使用 const 定义了一个常量后，并不会为这个常量分配空间，而是将这个常量值写入符号表中，这使得它成为一个编译期间的常量，没有存储与读内存的操作，它的效率也很高。在编译过程中若发现使用常量，则直接以符号表中的值替换；为了兼容 C 语言，编译过程中若发现对 const 使用了 extern 或者&操作符，则给对应的常量另外分配存储空间。

但是，当使用 & 去取这个常量的地址时，编译器会分配一个空间给这个变量，但之后这个变量的值仍旧从符号表中读取，不管这个变量的存储空间中的值如何变化，都不会对这个常量的值产生影响。如下例所示：

```c++
#include <iostream>

int main() {
  const int n = 10;
  int *p = (int *) (&n);
  *p = 20;
  std::cout << n << std::endl;
  std::cout << *p << std::endl;
  return 0;
}
```

```
10
20
```

C 语言编译器则不同，当使用 const 定义一个常量的时候，编译器会直接开辟一个内存空间来存储该常量，每次存取的时候都是从这个内存空间中存取，因此可以取得 const 变量的地址，然后用这个地址来间接地修改 const 变量。如下例所示：

```c++
#include <stdio.h>

int main() {
  const int n = 10;
  int *p = (int *) (&n);
  *p = 20;
  printf("%d\n", n);
  printf("%d\n", *p);
  return 0;
}
```

```
20
20
```

正因为如此，在 C 语言中如果使用下面的方式来定义数组，那么编译器会报错。

```c++
const int n = 10;
int a[n];
```

## switch 语句中的 case 结尾是否必须添加 break 语句

一般必须在 case 语句结尾添加 break 语句。因为一旦通过 switch 语句确定了入口点，从入口点的 case 语句开始会一直往下执行，除非遇到关键字 break，否则会执行满足这个 case 之后的其他 case 语句，直到 switch 结束或者遇到 break 为止。如果在 switch 中省略了 break 语句，那么匹配的 case 值后的所有情况（包括 default 情况）都会被执行。

## volatile 在程序设计中有什么作用

编译器在把源程序编译为目标代码的时候，通常都会做一些优化。例如，对于一些变量的存取而言，为了提高存取的效率，编译器有时会先把变量读取到一个寄存器中缓存起来，当以后再取变量值时，就直接从寄存器中取值，而不需要再从内存中去读取；在单线程环境下，这样的优化能显著提高程序的运行效率，但是，在多线程环境下就会有潜在的风险。假设存在一个线程 1 和线程 2 共享的变量 sharedObj，如果在线程 1 中把 sharedObj 缓存在寄存器中，那么当线程 2 对内存中 sharedObj 的值进行修改后，线程 1 无法读取到这个最新的值，因为线程 1 会从寄存器中读取，而不会从内存中读取。由此可见，在多线程编程的环境下，编译器的优化有可能会带来潜在的问题。

volatile 恰恰可以解决这个问题，它是一个类型修饰符（type specifier），用来修饰被不同线程访问和修改的变量。被 volatile 类型修饰的变量，系统每次用到它的时候都是直接从对应的内存中提取，而不会利用 cache 中的原有数值，系统对这种变量的处理不会做优化。所以，volatile 一般用于修饰多线程间被多个任务共享的变量和并行设备硬件寄存器等。

对于 volatile 关键字的作用，可以通过在代码中插入汇编代码，测试有无 volatile 关键字对程序最终代码的影响。

一个定义为 volatile 的变量是说这个变量可能会被意想不到地改变，这样编译器就不会对这个变量做优化（每次都从寄存器里读），而是去内存读取变量的最新值。准确地说，优化器在用到这个变量时必须每次都小心地重新读取（从内存中）这个变量的值，而不是使用保存在寄存器里的备份。

## 断言 ASSERT( ) 是什么

ASSERT( ) 一般被称为断言，是一个调试程序时经常使用的宏。它被定义在 `<assert.h>` 头文件中，通常用于判断程序中是否出现了非法的数据，在程序运行时，它计算括号内的表达式的值。如果表达式的值为 false(0)，则程序报告错误，终止运行，以免导致严重后果，同时也便于查找错误；如果表达式的值不为 0，则继续执行后面语句。在此需要强调一点，ASSERT( ) 捕获的是非法情况，而非错误情况，错误情况是必然存在的，并且一定需要做出相应的处理，而非法情况则不是，它可能只是漏洞而已。

需要注意的是，ASSERT( ) 只在 Debug 版本中有，在 Release 版本中则被忽略。还需要注意 ASSERT( ) 与 assert( ) 的区别，ASSERT( ) 是宏，而 assert( ) 是 ANSIC 标准中规定的函数，它与 ASSERT( ) 的功能类似，但是可以应用在 Release 版本中。

使用 assert( ) 的缺点是，频繁地调用会极大地影响程序的性能，增加额外开销。在调试结束后，可以通过在包含 `#include <assert.h>` 的语句之前插入 `#define NDEBUG` 来禁用 assert( ) 调用，示例代码如下：

```c++
#include<stdio.h>
#define NDEBUG
#include<assert.h>
```

对于 assert( ) 的使用，需要注意以下 5 个方面的内容：

1. 在函数开始处检验传入参数的合法性。例如：

```c++
assert(nNewSize>=0);
assert(nNewSize<=MAX_BUFFER_SIZE);
```

2. 每个 assert( ) 一般只检验一个条件，而不对多个条件进行检验，因为当同时检验多个条件时，如果断言失败，则无法直观地判断是哪个条件失败。

3. 不要使用 assert( ) 作为实现函数逻辑的语句，因为 assert( ) 一般在 Release 版本中，就禁用了，如果使用 assert( ) 作为逻辑判断语句，或者程序中出现类似 assert(i++<100 ) 的使用方式，会导致程序在 Debug 版本与 Release 版本中有不同的运行结果。

4. 并非所有的 assert( ) 都能代替过滤条件，对于有的地方，assert( ) 无法达到条件过滤的目的。

5. 一般在编程的时候，为了形成逻辑和视觉上的一致性，会将 assert( ) 与后面的语句之间空一行来隔开。

## 枚举变量的值如何计算

```c++
#include <stdio.h>

int main() {
  enum {
    a,
    b = 5,
    c,
    d = 4,
    e
  };

  printf("%d %d %d %d %d", a, b, c, d, e);

  return 0;
}
```

在枚举中，某个枚举变量的值默认为前一个变量的值加 1，而如果第一个枚举变量没有被赋值，则其默认值为 0。所以，在上例中，a，b，c，d，e 的值分别为 0，5，6，4，5，其中，b 与 e 的值都为 5，从这个例子中还可以看出枚举变量值是可以重复的。

## char str1[] = "abc" ; char str2[] = "abc" ; str1 与 str2 不相等，为什么

str1 和 str2 都是字符数组，每个字符串都有其自己的存储区，而 str1 与 str2 表示两个字符串的首地址，因为 str1 和 str2 的地址不同，所以 str1 与 str2 不相等。在 C/C++ 中，字符串主要有 3 种存储方式，下面通过一个例子来介绍这几种存储方式：

```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>

int main() {
  // 存储在栈上
  char str1[] = "abc";
  char str2[] = "abc";

  // 存储在常量区
  char *str3 = "abc";
  char *str4 = "abc";

  // 存储在堆上
  char *str5 = (char *) malloc(4);
  char *str6 = (char *) malloc(4);

  strcpy(str5, "abc");
  strcpy(str6, "abc");

  printf("%d\n", str1 == str2);
  printf("%d\n", str3 == str4);
  printf("%d\n", str5 == str6);

  return 0;
}
```

在上例中，str1 与 str2 两个字符数组都存储在栈空间中，而在栈中，每定义一个变量或数组，都会分配新的空间，由于 str1 与 str2 表示的是这两个数组的首地址，所以它们是不相等的。

对于 str3 和 str4 来讲，它们并非字符数组，而是字符指针，“abc” 以常量形式存于常量区， str3 和 str4 是指向这个常量的地址，由于相同的字符串常量在常量区中只可能存在一份，因此它们指向同一个常量，所以它们的值相等。

对于 str5 与 str6，它们也是字符指针，由于它们指向的空间是在堆空间申请的，而在堆空间每次都会分配不同的存储空间，因此它们的值也不相等。

![](../../assets/images/interview/questions/keywords/图1-1%20字符串存储方式.png)

从图 1-1 可以看出，str1 和 str2 是指在栈空间中字符数组的首地址（并没有单独的存储空间来存储 str1 和 str2 的值），str3 和 str4 的值为常量区中存放“abc”的地址，str5 和 str6 的值分别为堆中申请的空间的首地址。

## 为什么有时候 main( ) 函数会带参数？参数 argc 与 argv 的含义是什么

C 语言的设计原则是把函数作为程序的构成模块。在 C99 标准中，允许 main( ) 函数没有参数，或者有两个参数（有些实现允许更多的参数，但这只是对标准的扩展）。

命令行参数有时用来启动一个程序的执行。例如，`int main(int argc, char * argv[])`，其中，第一个参数 argc 表示命令行参数的数目，它是 int 类型；第二个参数 argv 是一个指向字符串的指针数组，由于参数的数目并没有内在的限制，所以 argv 是一个指向字符串的数组，这些数组中的每个元素都是指向一个字符串参数的指针。

一个 C 语言程序总是从 main( ) 函数开始执行。

## C++ 里面是不是所有的动作都是 main( ) 函数引起的

不是。对于 C++ 程序而言，静态变量、全局变量、全局对象的分配早在 main( ) 函数之前就已经完成了。所以，并不是所有的动作都是由 main( ) 引起的，main( ) 只不过是一个约定的函数入口，在 main( ) 函数中的代码执行之前，会调用一个由编译器生成的 _main( ) 函数，而 _main( ) 函数会进行所有全局对象的构造及初始化工作。

示例代码如下所示：

```cpp
#include <iostream>

class A {
public:
  A() { std::cout << "construct" << std::endl; }
  ~A() { std::cout << "destruct" << std::endl; }
};

A a;

int main() {
  std::cout << "main" << std::endl;
  return 0;
}
```

输出结果如下所示：

```bash
construct
main
destruct
```

程序在执行时，首先初始化全局变量，当这个变量是一个对象时，则会调用该对象的构造函数，所以在上例中，对象 a 的构造函数先执行，然后才执行 main( ) 函数。由此可见，在 C++ 语言中并非所有的动作都是 main( ) 函数引起的。

从上例同样可以看出，在 main( ) 函数退出之后还可以执行代码。对于全局对象，当程序退出的时候，对象的析构函数会被调用。

## `*p++` 与 `(*p)++` 等价吗？为什么

在 C 语言中，优先级由高到低的排序如下：

1. 函数符号 ( )、数组下标 []、数组下标符号. 和成员符号 ->，结合性从左往右。
2. 单目运算符：！、～、++、--、-(type) *、&和 sizeof，结合性从右往左。
3. 算术运算法：*、/、%，结合性从左往右。
4. + 和 -，结合性从左往右。
5. 移位运算符：<<、>> 和 >>>，结合性从左往右。
6. 关系运算符：<、< =、> 和 > =，结合性从左往右。
7. ==和!=，结合性从左往右。
8. 逻辑运算符：首先，对于按位运算符 &、^ 和|，&优先级高于 ^ ，^ 优先级高于 |，结合性从左往右；其次，对于逻辑运算符 && 与 ||，&& 优先级高于 ||，结合性从左往右。
9. 三目运算符? :，结合性从右往左；其次是赋值运算符 =，结合性从右往左；最后是逗号运算符，结合性从左往右。

对操作符的优先级总结如下：

1. 关系运算符优于逻辑运算符。
2. 移位运算符介于算术运算符和比较运算符之间。
3. 除单目运算符外，算术运算符的优先级最高。

所以，因为优先级顺序的问题，`*p++` 与 `(*p)++` 并不等价，前者先完成取值操作，然后对指针地址执行 `++` 操作；而后者为首先执行取值操作，然后对该值进行 `++` 运算。

## 前置运算与后置运算有什么区别

以 ++ 操作为例，对于变量 a，++a 表示对变量 a 对应的值加 1，然后增加后的结果放在寄存器中； a++ 表示变量 a 的值装入寄存器，然后增加内存中 a 的值。

## a 是变量，执行 (a++)+=a 语句是否合法

左值是指可以出现在等号左边的变量或表达式，它最重要的特点就是可写（可寻址）。也就是说，它的值可以被修改，如果一个变量或表达式的值不能被修改，那么它就不能作为左值。

右值是指只可以出现在等号右边的变量或表达式。它最重要的特点是可读。一般的使用场景都是把一个右值赋值给一个左值。

通常，左值可以作为右值，但是右值不一定是左值。

a++ 的实现原理为

```c
int temp = a;
a = a + 1;
return temp;
```

a++ 返回的值是编译器临时分配的临时变量 temp，而 temp 并不是程序中定义的可寻址的变量，因此不能作为左值。

```c++
#include <iostream>

int main() {
  int a = 1;
  (a++) += a; // error: lvalue required as left operand of assignment
  return 0;
}
```

对于++a来讲，它的实现原理为

```c
a = a + 1;
return a;
```

++a 返回的值是 a，a 是程序中定义的可寻址的变量，因此可以作为左值。

```c++
int main() {
  int a = 1;
  (++a) += a; // ok
  return 0;
}
```

## 如何进行 float、bool、int、指针变量与“零值”的比较

编写程序时，经常需要对比变量与“零值”。一般地，如果想使用 if 判断一个变量 var 是真还是假，可以直接使用 if(var)、if(!var)，表明其为“逻辑”判断；如果用 if 判断一个数值型变量 var （如 short、int、long 等），应该用 if(var==0)，表明是与 0 进行“数值”上的比较；而判断指针则最好使用 if(var==NULL)。对于浮点数的比较，首先需要考虑到的问题就是浮点型变量在内存中的存储导致它并不是一个精确的数，所以不可以将 float 变量用 “==” 或 “!=” 与数字比较，应该设法转化成 “>=” 或 “<=” 形式。

### int 类型

```c++
if (n==0)
if (n !=0)
```

### float 类型

无论是 float，还是 double 类型的变量，由于它们在内存中的存储机制与整型不同，有舍入误差，所以在计算机中，大多数浮点数都是无法精确表达的，很难用 A==B 来判定两个浮点数是否相同。在判断浮点数相等时，推荐使用用范围来确定，若 x 在某一范围内，就认为相等，至于范围怎么定义，要依据实际情况而定，float 和 double 也各有不同。所以都不可以用 “==” 或 “!=” 与任何数字比较，应该设法转化成 “>=” 或 “<=” 某个精度值。具体方式如下所示：

```c++
const float EPSINON=0.00001;
if ((x>=EPSINON)&&(x<=EPSINON))
```

上例中，EPSINON 的取值是 0.00001，而一般对于该值的选取主要是按照实际情况设置的。

需要注意的是，因为浮点数的精度误差，导致对于确切的两个浮点数 a 与 b，a+b 的值和 b+a 的值永远是相等的，而浮点数的运算是不可结合的，所以 (a+b)+c 的值和 a+(b+c) 的值就不一定相等了。

### bool 类型

以 bool 型变量 flag 为例，推荐使用下面的方法进行比较：

```c++
if(flag)
if(!flag)
```

### 指针类型

指针类型的变量，可以用 NULL 进行初始化，也可以用 0 进行初始化，但是不可以用 0x0 进行初始化。在判断指针是否为空时，推荐使用 if(ptr==NULL) 进行判断，而不是 if(ptr==0)。

## new/delete 与 malloc/free 的区别是什么

在 C++ 语言中，new/malloc 可以用来在堆空间中申请空间，对应的 delete/free 可以用来释放在堆中的空间，new/delete 和 malloc/free 只能配对使用。

当它们被用到一般的数据类型的时候（如 int、char 等），有着相同的效果，它们主要有如下区别：

1. malloc/free 是 C/C++ 的标准库函数，new/delete 是 C++ 的运算符。

2. new/delete 是在 C++ 语言中引入的，当使用 new 创建对象的时候，在把空间申请好以后，还会调用类的构造函数，而使用 delete 释放对象所占空间的时候，会首先调用类的析构函数，然后释放对象所占的空间。而 malloc/free 则无法实现这个功能。

3. new 能够自动计算需要分配的内存空间，而 malloc 需要手工计算字节数。例如，`int * p1 = new int[2]`，`int * p2 = (int * )malloc(2 * sizeof(int))`。

4. new 的返回值不需要进行强制类型转换，因为 new 内置了 sizeof、类型转换和类型安全检查功能；而 malloc 返回 void 类型的指针，它本身并不识别内存是什么类型，它只关心内存的总字节数，因此在使用的时候需要对 malloc 的返回值进行强制类型转化。

5. new 是类型安全的，而 malloc 不是。例如，`int * p = new float[2]`，编译时就会报错；而 `int * p = malloc(2 * sizeof(float))`，编译时编译器就无法指出错误。

6. new 一般由两步构成，分别是 new 操作和构造。new 操作对应 malloc，但 new 操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而 malloc 不行。

7. malloc/free 需要库文件 stdlib.h 支持，new/delete 则不需要库文件支持。

```c++
#include <iostream>
class A {
public:
  A() {
    std::cout << "A constructor" << std::endl;
  }

  ~A() {
    std::cout << "A destructor" << std::endl;
  }

private:
  int i;
};

int main() {
  A *pA = new A();
  delete pA;
  return 0;
}
```

需要注意的是，有空间的申请，就有空间的释放，否则就会出现内存泄漏的问题，所以 new/delete、malloc/free 必须配对使用。而且 delete 和 free 被调用后，内存不会立即收回，指针也不会指向空，delete 或 free 仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是，有可能由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该将指针指向置位空。

既然 new/delete 的功能完全覆盖了 malloc/free，为什么在 C++ 语言中没有取消掉 malloc/free，而是仍然将其保留呢？其实，由于 C++ 程序经常要调用 C 函数，而 C 程序只能用 malloc/free 管理动态内存，所以仍然保留了 malloc/free。

## 将引用作为返回值的优点

将引用作为返回值的优点是：在内存中不产生返回值的临时副本，从而大大提高了程序的安全性与效率。

将引用作为函数返回值类型的时候，一般需要注意以下 4 点内容：

1. 不能返回局部变量的引用。局部变量由于存储在栈中，在函数返回后栈会被销毁，因此被返回的引用就成为了“无所指”的引用，程序会进入未知状态，会引起程序错误，甚至崩溃。

2. 不能返回函数内部由 new 分配的内存的引用。这跟 1 中介绍的类似。因为被函数返回的引用 (new ) 分配的内存的地址的值也是存储在栈中的一个临时变量）只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由 new 分配）就无法释放，从而造成内存泄漏。

3. 可以返回类成员的引用，但最好是常引用类型。当对象的属性与某种业务规则相关联时，其赋值常常与某些其他属性或对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其他对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

4. 流操作符 << 和 >>。一般这两个操作符都支持连续使用，因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。

## C 语言中，整型变量 x 小于 0，是否可知 x×2 也小于 0

当 x<0 的时候，x×2 有可能会向下溢出，从而变成一个很大的正数。

```c++
#include <iostream>

int main() {
  int x = -2147483648;
  int y = x * 2;

  std::cout <<x <<std::endl;
  std::cout << y << std::endl;

  return 0;
}
```

上面的代码输出结果为：

```c++
-2147483648
0
```

可能是编译器的原因。

## exit(status) 是否与从 main( ) 函数返回的 status 等价

在 C 语言标准中，它们是等价的。

对于 exit( ) 函数而言，无论参数是几，其效果都是相同的，它们主要有下面 3 个不同点：

1. return 是语言级别的，它表示的是调用堆栈的返回；它仅仅从当前的函数中返回，只有 return 在主函数 main 的时候, 才会结束当前进程。而 exit( ) 函数是系统调用级别的，它表示了一个进程的结束，因此 exit( ) 函数可以用于在程序中随时结束进程。

2. main 函数在结束时，会隐式地调用 exit( ) 函数，它的功能是删除进程使用的内存空间，同时把错误信息返回给父进程。

3. 使用场景不同。return 主要使用场景为：根据函数输入（参数）得到一个输出，而通常来讲，这个输出是通过 return 来返回的，也就是 return 是作为实现函数功能的一个重要的语句。而 exit( ) 函数通常不用来实现函数的逻辑，只用来退出进程。

## 已知 String 类定义，如何实现其函数体

String 类定义如下：

```c++
class String {
public:
  String(const char *str = NULL);        // 普通构造函数
  String(const String &other);           // 拷贝构造函数
  ~String(void);                         // 析构函数
  String &operator=(const String &other);// 赋值函数
private:
  char *m_data;// 用于保存字符串
};
```

```c++
#include <cstring>
#include <iostream>

class String {
public:
  String(const char *str = NULL);        // 普通构造函数
  String(const String &other);           // 拷贝构造函数
  ~String(void);                         // 析构函数
  String &operator=(const String &other);// 赋值函数
  friend std::ostream &operator<<(std::ostream &os, const String &str);

private:
  char *m_data;// 用于保存字符串
};

String::String(const char *str) {
  if (str == NULL) {
    m_data = new char[1];
    *m_data = '\0';
  } else {
    int length = strlen(str);
    m_data = new char[length + 1];
    strcpy(m_data, str);
  }
}

String::String(const String &other) {
  int length = strlen(other.m_data);
  m_data = new char[length + 1];
  strcpy(m_data, other.m_data);
}

String::~String(void) { delete[] m_data; }

String &String::operator=(const String &other) {
  if (this == &other)
    return *this;
  delete[] m_data;
  int length = strlen(other.m_data);
  m_data = new char[length + 1];
  strcpy(m_data, other.m_data);
  return *this;
}

std::ostream &operator<<(std::ostream &os, const String &str) {
  os << str.m_data;
  return os;
}

int main() {
  String a("abcdefg");
  std::cout << a << std::endl;
  String b(a);
  std::cout << b << std::endl;
  String c = b;
  std::cout << c << std::endl;

  return 0;
}
```

## 在 C++ 语言中如何实现模板函数的外部调用

export 是 C++ 新增的关键字，它的作用是实现模板函数的外部调用，类似于 extern 关键字。

### extern 的作用

extern 在 C++ 语言中总共有两个作用：一是解决 C++ 与 C 语言编译的时候名字匹配的问题；二是未来引用其他模块的代码。

在 C/C++ 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以其他模块中使用。

在某些情况下，为了防止忘记初始化全局变量，会在 “.h” 文件中直接初始化变量，编译的时候会报链接错误，这是因为编译器会在每个包含该头文件的源文件中生成一个该全局变量的定义，这样就会导致重复定义的错误。

可以使用 extern 来解决，解决方法是在 “.cpp” 文件中用 extern 该变量。编译器就知道是引自于外部的一个编译模块了，不会在本模块中再重复定义一个。但这种情况必须将所有的函数都声明为 extern。很显然这种使用方法很烦琐。

### export 的作用

export 是 C/C++ 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在其他模块中使用。

为了访问其他文件中的变量或对象，对普通类型（包括基本数据类、结构和类）可以利用关键字 extern 来使用这些变量或对象，而对于模板类型而言，可以在头文件中声明模板类和模板函数，在代码文件中使用关键字 export 来定义具体的模板类对象和模板函数，然后在其他用户代码文件中，包含声明头文件后，就可以使用这些对象和函数了。

## 在 C++ 语言中，关键字 explicit 有什么作用

在 C++ 语言中，如下声明是合法的。

```c++
String s1 = "hello";
```

上例中，String s1 = "hello" 会执行隐式转换，等价于 `String s1 = String("hello")`。为了避免发生这种情况，C++ 引入了关键字 explicit，它可以阻止隐式转换的发生。也就是说，被声明为 explicit 的构造函数不能使用隐式转换。

在 C++ 语言中，有一个参数的构造函数（或者除了第一个参数外，其余参数都有默认值的多参构造函数）一般具备两个功能：构造器和隐含的类型转换操作符。所以，当 AAA = XXX，恰好 XXX 的类型正好是 AAA 类的单参数构造器的参数类型的时候，编译器就自动调用这个构造器，创建一个 AAA 的对象。

## C++ 中异常的处理方法以及使用了哪些关键字

异常是指程序运行时（非编译）所发生的非正常情况或错误，当程序违反了语义规则时，编译器就会将出现的错误表示为一个异常并抛出。这个异常可以在 catch 程序块中进行捕获，然后进行处理。而异常处理的目的则是为了提高程序的安全性与健壮性。

一般来讲，异常处理的基本代码结构为：

```c++
try {
    // 可能出现异常的代码
} catch (ExceptionType1& e1) {
    // 处理 ExceptionType1 异常的代码
} catch (ExceptionType2& e2) {
    // 处理 ExceptionType2 异常的代码
} catch (ExceptionType3& e3) {
    // 处理 ExceptionType3 异常的代码
}
```

在 C++ 语言中异常处理主要用到的关键字有 try、catch 和 throw。

## 回调函数

回调函数就是被调用者回头调用的函数，它是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，此时就可以称它为回调函数。回调函数不是由该函数的实现方直接调用的，而是在特定的事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。

使用回调函数实际上就是在调用某个函数（通常是 API 函数）时，将自己的一个函数（这个函数为回调函数）的地址作为参数传递给被调用函数。而该被调用函数在需要的时候，利用传递的地址来调用这个回调函数。

回调函数与应用程序接口 (API) 非常接近，它们都是跨层调用的函数，但区别是 API 是低层提供给高层的调用，一般这个函数对高层都是已知的；而回调函数正好相反，它是高层提供给低层的调用，对于低层，它是未知的，必须由高层进行安装，这个安装函数其实就是一个低层提供的 API，安装后低层不知道这个回调的名字，但它通过一个函数指针来保存这个回调函数，在需要调用时，只需引用这个函数指针和相关的参数指针即可。

## strlen("\0")=？sizeof("\0")=？

```c++
#include <stdio.h>
#include <string.h>

int main() {
  printf("%d\n", strlen("\0"));// 0
  printf("%d\n", sizeof("\0"));// 2
  return 0;
}
```

strlen 用来计算字符串的长度（在 C/C++ 中，字符串是以‘ \0 ’作为结束符的），它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符 '\0' 为止，然后返回计数器值。

sizeof 是 C 语言的关键字，它以字节的形式给出了其**操作数的存储大小**，操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型决定。

具体而言，strlen 与 sizeof 的差别表现在以下 5 个方面。

1. sizeof 是运算符（事实上，sizeof 既是关键字，也是运算符，但不是函数），而 strlen 是函数。sizeof 后如果是类型，则必须加括弧，如果是变量名，则可以不加括弧。

2. sizeof 运算符的结果类型是 size_t，它在头文件中 typedef 为 unsigned int 类型。该类型保证能够容纳实现所建立的最大对象的字节大小。

3. sizeof 可以用类型作为参数，strlen 只能用 char * 作参数，而且必须是以‘ \0 ’结尾的。sizeof 还可以以函数作为参数，如 int g( )，则 sizeof(g( )) 的值等于 sizeof(int) 的值，在 32 位计算机下，该值为 4。

4. 大部分编译程序的 sizeof 都是在编译的时候计算的，所以可以通过 sizeof(x) 来定义数组维数。而 strlen 则是在运行期计算的，用来计算字符串的实际长度，不是类型占内存的大小。例如，`char str[20] = "0123456789"`，字符数组 str 是编译期大小已经固定的数组，在 32 位机器下，为 `sizeof(char) * 20 = 20`，而其 strlen 大小则是在运行期确定的，所以其值为字符串的实际长度 10。

5. 当数组作为参数传给函数时，传递的是指针，而不是数组，即传递的是数组的首地址。例如：

```c++
fun(char [8])
fun(char [])
```

以上两个函数都等价于 `fun(char * )`。在 C++ 里，参数传递数组永远都是传递指向数组首元素的指针，事实上，编译器并不知道数组的大小，如果想在函数内知道数组的大小，需要这样做：进入函数后用 memcpy 复制出来，长度由另一个形参传进去。

## 对于结构体而言，为什么 sizeof 返回的值一般大于期望值

struct 是一种复合数据类型，其构成元素既可以是基本数据类型，如 int、double、float、short、char 等，也可以是复合数据类型，如数组、struct、union 等数据单元。

一般而言，struct 的 sizeof 是所有成员对齐后长度相加，而 union 的 sizeof 是取最大的成员长度。

在 struct 结构中，编译器为结构的每个成员按其自然边界 (alignment) 分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

字节对齐也称为字节填充，它是 C++ 编译器的一种技术手段，主要是为了在空间与复杂度上达到平衡。简单地讲，是为了在可接受的空间浪费的前提下，尽可能地提高对相同运算过程的最少（快）处理。字节对齐的作用不仅是便于 CPU 的快速访问，使 CPU 的性能达到最佳，而且可以有效地节省存储空间。

例如，**32 位计算机的数据传输是 4 字节，64 位计算机的数据传输是 8 字节**，这样，struct 在默认的情况下，编译器会对 struct 的结构进行（32 位机）4 的倍数或（64 位机）8 的倍数的数据对齐。对于 32 位机来说，4 字节对齐能够使 CPU 访问速度提高，如一个 long 类型的变量，如果跨越了 4 字节边界存储，那么 CPU 要读取两次，这样效率就低了，但需要注意的是，如果在 32 位机中使用 1 字节或者 2 字节对齐，不仅不会提高效率，反而会使变量访问速度降低。

在默认情况下，编译器为每一个变量或数据单元按其自然对界条件分配空间。但是，可以通过下面的方法来改变默认的对界条件。

1. 使用伪指令 #pragma pack (n)，编译器将按照 n 个字节对齐。

2. 使用伪指令 #pragma pack ( )，取消自定义字节对齐方式。

3. 另外，还有一种方式：`_attribute((aligned (n)))`，让所作用的结构成员对齐在 n 字节自然边界上。如果结构中有成员的长度大于 n，则按照最大成员的长度来对齐。`_attribute_((packed))`，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。

```c++
struct test {
  char x1;
  short x2;
  float x3;
  char x4;
}
```

由于编译器默认情况下会对 struct 作边界对齐，结构的第一个成员 x1，其偏移地址为 0，占据了第 1 个字节，第二个成员 x2 为 short 类型，其起始地址必须 2 字节对齐，因此编译器在 x2 和 x1 之间填充了一个空字节。结构的第三个成员 x3 和第四个成员 x4 恰好落在其自然边界地址上，在它们前面不需要额外的填充字节。在 test 结构中，成员 x3 要求 4 字节对界，是该结构所有成员中要求的最大边界单元，因而 test 结构的自然对界条件为 4 字节，编译器在成员 x4 后面填充了 3 个空字节。整个结构占据的空间为 12 字节。

字节对齐的细节和编译器实现相关，但一般而言，满足以下 3 个准则：

1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。

2. 结构体每个成员相对于结构体首地址的偏移量 (offset) 都是成员大小的整数倍。如有需要，编译器会在成员之间加上填充字节。

3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

需要注意的是，基本类型是指前面提到的像 char、short、int、float、double 这样的内置数据类型，这里所说的“数据宽度”就是指其 sizeof 的大小，在 32 位机器上，这些基本数据类型的 sizeof 大小分别为 1、2、4、4、8。由于结构体的成员可以是复合类型，所以在寻找最宽基本类型成员时，应当包括复合类型成员的子成员，而不是把复合成员看成是一个整体。如果一个结构体中包含另外一个结构体成员，那么此时最宽基本类型成员不是该结构体成员，而是取基本类型的最宽值。但在确定复合类型成员的偏移位置时，则是将复合类型作为整体看待，即复杂类型（如结构）的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，可以最小化长度，达到程序优化的目的。

```c++

```
