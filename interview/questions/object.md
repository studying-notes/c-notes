---
date: 2022-10-28T14:14:32+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "面向对象"  # 文章标题
url:  "posts/cpp/interview/questions/object"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## 面向对象与面向过程有什么区别

面向对象是**把数据及对数据的操作方法放在一起，作为一个相互依存的整体**，即对象。对同类对象抽象出其共性，即类，类中的大多数数据只能被本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。例如，站在抽象的角度，人类具有身高、体重、年龄、血型等特征。人类仅仅只是一个抽象的概念，它是不存在的实体，但是所有具备人类这个群体的属性与方法的对象都叫人，这个对象人是实际存在的实体，每个人都是人这个群体的一个对象。

面向过程是一种**以事件为中心**的开发方法，就是**自顶向下顺序执行**，逐步求精，其程序结构是按功能划分为若干个基本模块，这些模块形成一个树状结构，各模块之间的关系也比较简单，在功能上相对独立，每一模块内部一般都是由顺序、选择和循环三种基本结构组成的，其模块化实现的具体方法是使用子程序，而程序流程在写程序时就已经决定。

具体而言，二者主要有以下 4 个方面的不同之处：

1. 出发点不同。面向对象方法是用符合常规思维方式来处理客观世界的问题，强调把问题域的要领直接映射到对象及对象之间的接口上。而面向过程方法则不然，它强调的是过程的抽象化与模块化，它是以过程为中心构造或处理客观世界问题的。

2. 层次逻辑关系不同。面向对象方法是用计算机逻辑来模拟客观世界中的物理存在，以对象的集合类作为处理问题的基本单位，尽可能地使计算机世界向客观世界靠拢，以使问题的处理更清晰直接。面向对象方法是用类的层次结构来体现类之间的继承和发展。而面向过程方法处理问题的基本单位是能清晰准确地表达过程的模块，用模块的层次结构概括模块或模块间的关系与功能，把客观世界的问题抽象成计算机可以处理的过程。

3. 数据处理方式与控制程序方式不同。面向对象方法将数据与对应的代码封装成一个整体，原则上其他对象不能直接修改其数据，即对象的修改只能由自身的成员函数完成。控制程序方式上是通过“事件驱动”来激活和运行程序。而面向过程方法是直接通过程序来处理数据，处理完毕后即可显示处理结果。在控制程序方式上是按照设计调用或返回程序，不能自由导航，各模块之间存在着控制与被控制、调用与被调用的关系。

4. 分析设计与编码转换方式不同。面向对象方法贯穿软件生命周期的分析、设计及编码之间，是一种平滑过程，从分析到设计再到编码采用一致性的模型表示，即实现的是一种无缝连接。而面向过程方法强调分析、设计及编码之间按规则进行转换，贯穿软件生命周期的分析、设计及编码之间，实现的是一种有缝的连接。

## 面向对象的基本特征有哪些

面向对象方法首先对需求进行合理分层，然后构建相对独立的业务模块，最后通过整合各模块，达到高内聚、低耦合的效果，从而满足客户要求。

具体而言，它有 3 个基本特征：封装、继承和多态。

1. 封装是指将客观事物抽象成类，每个类对自身的数据和方法进行保护。类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。C++ 中，类是一种封装手段，采用类来描述客观事物的过程就是封装，本质上是对客观事物的抽象。

2. 继承是指可以使用现有类的所有功能，而不需要重新编写原来的类，它的目的是为了进行代码复用和支持多态。它一般有 3 种形式：实现继承、可视继承、接口继承。其中，实现继承是指使用基类的属性和方法而无需额外编码的能力；可视继承是指子窗体使用父窗体的外观和实现代码；接口继承仅使用属性和方法，实现滞后到子类实现。前两种（类继承）和后一种（对象组合= > 接口继承以及纯虚函数）构成了功能复用的两种方式。通过继承创建的新类称为“派生类”或“子类”，被继承的类称为“父类”“基类”或“超类”，而继承的过程是从一般到特殊（具体）的过程。

3. 多态是指同一个实体同时具有多种形式，它主要体现在类的继承体系中，它是将父对象设置成为和一个或更多的它的子对象相等的技术，赋值以后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单地说，就是允许将子类对象的指针赋值给父类类型的指针，在运行时根据具体指向对象的类型来调用对应类。

## 什么是深拷贝？什么是浅拷贝

如果一个类拥有资源（堆或者是其他系统资源），当这个类的对象发生复制过程时，资源重新分配，这个过程就是深拷贝；反之对象存在资源，但复制过程并未复制资源的情况视为浅拷贝。

例如，在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位复制，也就是把对象里的值完全复制给另一个对象，如 A=B，这时，如果类 B 中有一个成员变量指针已经申请了内存，那么类 A 中的那个成员变量也指向同一块内存。这就出现了问题：当类 B 把内存释放后，这时类 A 内的指针就变成野指针了，导致运行错误。

```c++
#include <cstring>
#include <iostream>

class CA {
public:
  CA(int b, char *cstr);
  CA(const CA &C);
  void Show();
  ~CA();

private:
  int a;
  char *str;
};

CA::CA(int b, char *cstr) {
  a = b;
  str = new char[b];
  strcpy(str, cstr);
}

CA::CA(const CA &C) {
  a = C.a;
  str = new char[a];
  // 深拷贝
  strcpy(str, C.str);
  // 浅拷贝
  //  str=C.str;
}

void CA::Show() {
  std::cout << "a = " << a << std::endl;
  std::cout << "str = " << str << std::endl;
}

CA::~CA() {
  delete[] str;
}

int main() {
  CA A(10, "Hello");
  CA B = A;
  B.Show();

  return 0;
}
```

浅拷贝资源后，释放资源时会产生资源归属不清的情况，导致程序运行出错。`Test(Test & c_t)` 是自定义的拷贝构造函数，拷贝构造函数的名称必须与类名称一致，函数的形式参数是本类型的一个引用变量，且必须是引用。当用一个已经初始化过了的自定义类类型对象去初始化另一个新构造的对象时，拷贝构造函数就会被自动调用。如果没有自定义拷贝构造函数时，系统将会提供给一个默认的拷贝构造函数来完成这个过程，上面代码的复制核心语句就是通过 `Test(Test & c_t)` 拷贝构造函数内的 `p1 = c_t.p1` 语句来完成的。

## 什么是友元

类具有封装、继承、多态、信息隐藏的特性，只有类的成员函数，才可以访问类的标记为 private 的私有成员，非成员函数可以访问类中的公有成员，但是却无法访问私有成员，为了**使非成员函数可以访问类的成员**，唯一的做法就是将成员都定义为 public，但如果将数据成员都定义为公有的，这又破坏了信息隐藏的特性。而且，对某些成员函数多次调用时，由于参数传递、类型检查和安全性检查等都需要时间开销，从而影响程序的运行效率。

友元正好解决了这一棘手的问题。使用友元函数时，一般需要注意以下 6 个方面的问题：

1. 必须在类的说明中说明友元函数，说明时以关键字 friend 开头，后跟友元函数的函数原型，友元函数的说明可以出现在类的任何地方，包括 private 和 public 部分。

2. 友元函数不是类的成员函数，所以友元函数的实现与普通函数一样，在实现时不用"::"指示属于哪个类，只有成员函数才使用"::"作用域符号。

3. 友元函数不能直接访问类的成员，只能访问对象成员。

4. 友元函数可以访问对象的私有成员，但普通函数不行。

5. 调用友元函数时，在实际参数中需要指出要访问的对象。

6. 类与类之间的友元关系不能继承。

友元一般定义在类的外部，但它需要在类体内进行说明，为了与该类的成员函数加以区别，说明时在前面加关键字 friend。需要注意的是，友元函数不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类。友元函数是指某些虽然不是类成员却能够访问类的所有成员的函数。友元函数的特点是：能够访问类中的私有成员的非成员函数。从语法上看，友元函数与普通函数一样，即在定义上和调用上与普通函数一样。成员函数和非成员函数最大的区别在于，成员函数可以是虚的，而非成员函数不行。所以，如果有一个函数必须进行动态绑定，就要采用虚函数，而虚函数必定是某个类的成员函数。

```c++
#include <cstring>
#include <iostream>

class String {
  friend std::ostream &operator<<(std::ostream &os, const String &str);
  friend std::istream &operator>>(std::istream &is, String &str);

public:
  String() : String("") {}
  String(const char *str) {
    m_size = strlen(str);
    m_str = new char[m_size + 1];
    strcpy(m_str, str);
  }

private:
  char *m_str;
  int m_size;
};

std::ostream &operator<<(std::ostream &os, const String &str) {
  os << str.m_str;
  return os;
}

std::istream &operator>>(std::istream &is, String &str) {
  char *buffer = new char[1000];
  is >> buffer;
  str = String(buffer);
  delete[] buffer;
  return is;
}

int main() {
  String str1 = "Hello";
  std::cout << str1 << std::endl;
  return 0;
}
```

## 拷贝构造函数与赋值运算符的区别

在 C++ 语言中，如果一个类没有编写构造函数，那么编译器会提供 4 个默认构造函数。

1. 默认构造函数：无参构造函数，不做任何事情。
2. 拷贝构造函数：有一个参数，参数是该类的引用，用于初始化对象。
3. 赋值运算符：有一个参数，参数是该类的引用，用于赋值。
4. 析构函数：无参构造函数，用于释放对象。

```c++
#include <iostream>

class A {
public:
  A() { std::cout << "A()" << std::endl; } //1
  A(const A &a) { std::cout << "A(const A &a)" << std::endl; }//2
  A &operator=(const A &a) {//3
    std::cout << "A &operator=(const A &a)" << std::endl;
    return *this;
  }
  ~A() { std::cout << "~A()" << std::endl; }//4
};
```

拷贝构造函数是一种特殊的构造函数，用来完成一些基于同一类的其他对象的构建及初始化工作。具体而言，拷贝构造函数有如下特点：

1. 该函数名与类同名，因为它也是一种构造函数，并且该函数不指定返回类型。

2. 该函数只有一个参数，并且是对这个类的对象的引用。

3. 每个类都必须有一个拷贝构造函数。

4. 如果程序员没有显式地定义一个拷贝构造函数，那么，C++ 编译器会自动生成一个缺省的拷贝构造函数。

5. 拷贝构造函数的目的是建立一个新的对象实体，所以一定要保证新创建的对象有独立的内存空间，而不是与先前的对象共用。

虽然编译器会提供一个默认的拷贝构造函数，但是在定义类的时候，有时需要，甚至强烈推荐显式地定义拷贝构造函数用来实现特定的用户操作，最常用的是实现深拷贝。

而赋值操作符则不一样，它用已存在的对象来创建另一个对象，给对象赋予一个新的值，显然该对象原来就有值，所以赋值函数只能被已经存在了的对象调用，而不能凭空产生。而且如果不主动编写拷贝构造函数和赋值函数，编译器将以“位复制”的方式自动生成默认的函数，如果类中含有指针变量，那么位复制只实现了浅拷贝。

拷贝构造函数与赋值运算符的主要区别：拷贝构造函数生成新的类对象，而赋值运算符不能。简单来说，当进行一个类的实例初始化时，调用的是构造函数，但如是用其他实例来初始化，则调用拷贝构造函数，非初始化时对这个实例进行赋值调用的是赋值运算符。

## C++ 语言中默认会产生哪些成员函数

C++ 语言中，空类默认会产生以下 6 个函数：默认构造函数、拷贝构造函数、析构函数、赋值运算符重载函数、取址运算法重载函数、const 取址运算符重载函数。

```cpp
class A
{
public:
  A() {}
  A(const A &a) {}
  ~A() {}
  A &operator=(const A &a) {}
  A *operator&() {}
  const A *operator&() const {}
};
```

默认构造函数和析构函数实际上什么也不做，它们只是用于创建和销毁类的对象。拷贝构造函数是一种特殊的构造函数，拷贝构造函数的第一个参数必须为 `type X &` 或 `type const X &`。要么不存在其他参数，如果存在其他参数，其他参数必须有默认值。

## 基类的构造函数/析构函数是否能被派生类继承

基类的构造函数 / 析构函数不能被派生类继承。

基类的构造函数不能被派生类继承，派生类中需要声明自己的构造函数。设计派生类的构造函数时，不仅要考虑派生类所增加的数据成员初始化，也要考虑基类的数据成员的初始化。声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化，需要调用基类构造函数完成。

基类的析构函数也不能被派生类继承，派生类需要自行声明析构函数。声明方法与一般（无继承关系时）类的析构函数相同，不需要显式地调用基类的析构函数，系统会自动隐式调用。需要注意的是，析构函数的调用次序与构造函数相反。

## 初始化列表和构造函数初始化的区别

初始化列表一般如下：

```c++
Object::Object(int_x, int_y):x(_x),y(_y){}
```

构造函数初始化一般通过构造函数实现。示例如下：

```cpp
Object::Object(int _x, int _y)
{
  x = _x;
  y = _y;
}
```

上面的构造函数（使用初始化列表的构造函数）显式地初始化类的成员，而没使用初始化列表的构造函数是对类的成员赋值。

**初始化列表和赋值对内置类型的成员没有大的区别**，在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的。

对非内置类型（类中的成员变量是一个对象）来讲，初始化列表有更好的性能，因为**类类型的数据成员对象在进入函数体前已经构造完成**，然后调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，这通过调用一个赋值操作符才能完成（如果并未提供，则使用编译器提供的默认成员赋值行为）。为了避免两次构造，推荐使用类构造函数初始化列表。示例代码如下：

```cpp
#include <iostream>

class Food {
public:
  Food() {
    std::cout << "Food constructor" << std::endl;
  }
  Food(const Food &other) {
    std::cout << "Food copy constructor" << std::endl;
  }
  Food &operator=(const Food &other) {
    std::cout << "Food assignment operator" << std::endl;
    return *this;
  }
};

class Dog {
private:
  Food food;

public:
  Dog(Food &f) : food(f) {
  }
  Dog(Food &f, int n) {
    food = f;
  }
};

int main() {
  Food food;
  Dog dog1(food);
  std::cout << "----------------" << std::endl;
  Dog dog2(food, 1);
  return 0;
}
```

```
Food constructor
Food copy constructor
----------------
Food constructor
Food assignment operator
```

## C++ 中有哪些情况只能用初始化列表，而不能用赋值

构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面都跟一个放在括号中的初始化式。例如，`Example::Example:ival(0),dval(0.0){}`，其中 ival 与 dval 是类的两个数据成员。

在 C++ 语言中，赋值与初始化列表的原理不一样，赋值是删除原值，赋予新值，初始化列表开辟空间和初始化是同时完成的，直接给予一个值。

所以，在 C++ 中，赋值与初始化列表的使用情况也不一样，只能用初始化列表，而不能用赋值的情况一般有以下 3 种：

1. 当类中含有 const 常量、reference 引用变量时，只能初始化，不能对它们进行赋值。常量不能被赋值，只能被初始化，所以必须在初始化列表中完成，C++ 的引用也一定要初始化，所以必须在初始化列表中完成。

2. 派生类在构造函数中要对自身成员初始化，也要对继承过来的基类成员进行初始化，当基类没有默认构造函数的时候，通过在派生类的构造函数初始化列表中调用基类的构造函数实现。

3. 如果成员类型是没有默认构造函数的类，也只能使用初始化列表。若没有提供显式初始化时，则编译器隐式使用成员类型的默认构造函数，此时编译器尝试使用默认构造函数将会失败。

## 类的成员变量的初始化顺序

在 C++ 语言中，类的成员变量的初始化顺序只与变量在类中的声明顺序有关，与在构造函数中的初始化列表的顺序无关。而且静态成员变量先于实例变量，父类成员变量先于子类成员变量，父类构造函数先于子类构造函数。

```c++
#include <iostream>

class A {
  int n1, n2;

public:
  A() : n2(1), n1(n2 + 1){};
  void print() {
    std::cout << "n1 = " << n1 << ", n2 = " << n2 << std::endl;
  }
};

int main() {
  A a;
  a.print();
  return 0;
}
```

```
n1 = 1, n2 = 1
```

n1 与 n2 初始化的顺序与它们声明的顺序是相同的。如果 n2 首先初始化，那么 n2=1，n1=n2+1=2。显然运行结果不是这样的。

从全局看，变量的初始化顺序如下：

1. 基类的静态变量或全局变量。
2. 派生类的静态变量或全局变量。
3. 基类的成员变量。
4. 派生类的成员变量。

## 当一个类为另一个类的成员变量时，如何对其进行初始化

对于类对象的数据成员，应使用成员初始化列表进行初始化。

```c++
#include <iostream>

class ABC {
public:
  ABC(int a, int b, int c) {}

private:
  int a;
  int b;
  int c;
};

class MyClass {
public:
  MyClass(int a, int b, int c) : abc(a, b, c) {}

private:
  ABC abc;
};

int main() {
  return 0;
}
```

上例中，因为类 ABC 有了显式的带参数的构造函数，编译器就不会给类 ABC 提供一个默认的无参数的构造函数了，因此也就无法依靠编译器来调用类 ABC 的默认构造函数来进行初始化了。所以必须显式调用类 ABC 的构造函数。

ABC 类对象是 MyClass 的成员，如果要初始化对象 abc，只能用成员初始化列表，没有其他办法将参数传递给 ABC 类构造函数。

## C++ 能设计实现一个不能被继承的类吗

C++ 能实现不被继承的类，但是需要自己实现。

为了使类不被继承，最好的办法是使子类不能构造父类的部分，此时子类就无法实例化整个子类。在 C++ 语言中，子类的构造函数会自动调用父类的构造函数，子类的析构函数也会自动调用父类的析构函数，所以只要把类的构造函数和析构函数都声明为 private，那么当一个类试图从它那继承时，必然会由于试图调用构造函数、析构函数而导致编译错误。此时该类不能被继承。

但由此会造成一个问题，private 的构造函数与析构函数无法得到该类的实例。此时可以通过定义静态来创建和释放类的实例。这也是经典的单例设计模式的实现原理。程序示例如下：

```c++
class FinalClass {
public:
  static FinalClass *GetInstance() {
    return new FinalClass();
  }
  static void DeleteInstance(FinalClass *pInstance) {
    delete pInstance;
  }

private:
  FinalClass() {}
  ~FinalClass() {}
};
```

## 如何设置类的构造函数的可见性

如果不想让外界用户直接构造一个类（假设这个类的名字为 A）的对象，而希望用户只能构造这个类 A 的子类，那就可以将类 A 的构造函数 / 析构函数声明为 protected，而将类 A 的子类的构造函数 / 析构函数声明为 public。

如果将构造函数 / 析构函数声明为 private，那只有这个类的“内部”的函数才能构造这个类的对象。这里说的“内部”是指类的成员函数。

因为在外部不能定义对象，所以不能通过对象调用成员函数，如果想调用成员函数，可以提供一个静态的 public 的函数 getInstance 来获取这个类的对象。

## 构造函数没有返回值，那么如何得知对象是否构造成功

这里的“构造”不单指分配对象本身的内存，而是指在建立对象时做的初始化操作（如打开文件、连接数据库等）。

因为构造函数没有返回值，所以通知对象的构造失败的唯一方法就是在构造函数中抛出异常。构造函数中抛出异常将导致对象的析构函数不被执行，当对象发生部分构造时，已经构造完毕的子对象将会逆序地被析构。

## 构造函数为什么没有返回值

构造函数与普通函数有很多不同的地方，构造函数在对象不存在的时候可以被调用，而普通函数只有在对象被创建出来后才可以被调用；其次，构造函数是被编译器来调用的，程序员不能显式地调用构造函数，而普通函数则可以被显式地调用。

对象的创建可以分为两个步骤：

1. 内存的分配。

2. 内存的初始化。

对于内存的分配来讲，由于编译器知道类的详细构造，因此编译器可以完成内存的分配，而不需要构造函数的参与。但是，对于内存的初始化来讲，它是与用户想实现的功能相关的，由于编译器没有这个上下文，所以内存的初始化主要由构造函数完成。例如：

```c++
MyClass *obj = new MyClass ;
```

从上面的代码可以看出，创建对象时，得到的结果的类型是确定的，编译器会默认地认为构造函数处理的初始化与这个类相关。由此可以看出，当一个对象在创建的时候，编译器会默认调用对应类的构造函数来实现内存的初始化，得到的结果就是这个类的一个对象，用户不会去显式调用构造函数。

## public 继承、protected 继承、private 继承的区别

public（公有）继承、protected（保护）继承和 private（私有）继承是常见的 3 种继承方式。

1. 公有继承

对于子类的对象而言，采用公有继承时，基类成员对子类对象的可见性与一般类成员对对象的可见性相同，公有成员可见，其他成员不可见。

对于子类而言，基类的公有成员和保护成员可见；基类的公有成员和保护成员作为派生类的成员时，它们都维持原有的可见性（基类 public 成员在子类中还是 public，基类 protected 成员在子类中还是 protected() ；基类的私有成员不可见，基类的私有成员依然是私有的，子类不可访问。

2. 保护继承

保护继承的特点是：基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问。基类的私有成员仍然是私有的。由此可以看出，基类的所有成员对子类的对象都是不可见的。

3. 私有继承

私有继承的特点是，基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。

表 1-9 所示为成员访问控制列表。

| 基类性质 | 继承性质 | 派生类性质 |
| -------- | -------- | -------- |
| public | public | public |
| protected | public | protected |
| private | public | 不能访问 |
| public | protected | protected |
| protected | protected | protected |
| private | protected | 不能访问 |
| public | private | private |
| protected | private | private |
| private | private | 不能访问 |

## C++ 提供默认参数的函数吗

C++ 可以给函数定义默认参数值。在函数调用时如果没有提供参数，就自动使用默认参数。

默认参数的语法与使用如下：

1. 在函数声明或定义时，直接对参数赋值，这就是默认参数。

2. 在函数调用时，省略部分或全部参数。这时可以用默认参数来代替。

默认参数在函数声明中提供，当有声明又有定义时，定义中不允许默认参数。如果函数只有定义，则默认参数才可出现在函数定义中。

使用默认参数时，一般需要注意以下 3 个问题：

1. 如果一个函数中有多个默认参数，则形参分布中，默认参数应从右至左逐渐定义。例如：

```c++
void fun(int a=1,int b,int c=3,int d=4);
void fun(int a,int b=2,int c=3,int d=4);
```

上例中，第①种声明方法是错误的，而第②种声明方法是正确的。因为如果调用fun(3)，此时无法确定这个参数是传递给 a，还是 b。由此，第①种声明方法是错误的。

1. 在默认参数调用时，调用顺序为从左到右逐个调用。例如，首先声明一个带默认参数的函数 void mal(int a, int b = 3, int c = 5)，函数 mal(3, 8, 9) 在调用时有指定参数，则不使用默认参数，是合法调用；函数 mal(3, 5) 在调用时只指定两个参数，按从左到右的顺序调用，相当于 mal(3,5,5)，是合法调用；函数 mal(3) 在调用时只指定 1 个参数，按从左到右的顺序调用，相当于 mal(3,3,5)，是合法调用；而函数 mal() 因为 a 没有默认值，所以调用错误。

2. 默认参数可将一系列简单的重载函数合成为一个。例如，下面的 3 个重载函数：

```c++
void f(int,int){//...}
void f(int a){return f(a,4);}
void f( ){return f(3,4);}
```

可以用下面的默认参数的函数来替代。

```c++
void f(int=3,int=4);
```

上例中，当调用 f() ;时，即调用 f(3,4) ;，它是第 3 个声明的重载函数。当调用 f(6) ;时，即调用 f(6,4) ;，它是第 2 个声明的重载函数。当调用 f(7,8) ;时，即调用第 1 个声明的重载函数。

如果一组重载函数（可能带有默认参数）都允许相同实参个数的调用，将会引起调用的二义性。例如：

```c++
void func(int);//重载函数之一
void func(int,int=4);//重载函数之二，带有默认参数
void func(int=3,int=4);//重载函数三，带有默认参数
func(7);//错误：到底调用3个重载函数中的哪一个
func(20,30);//错误：到底调用后面2个重载函数的哪一个
```

## 如何解决多重继承中存在的钻石问题

```
D -> B -> A
D -> C -> A
```

类 B 和 C 都继承自 A，而类 D 继承自 B 和 C，形成了多重继承。由于这个继承关系对应的类图像一个钻石，因此在这种多重继承中存在的问题就被称为“钻石问题”。

```c++
#include <iostream>

class A {
public:
  int f() {
    return 1;
  };
};

class B : public A {};
class C : public A {};

class D : public B, public C {};

int main() {
  D d;
  std::cout << d.f() << std::endl;
  return 0;
}
```

在上面的代码中，由于类 B 和类 C 都继承自类 A，因此，类 B 和类 C 的类内部本身就会各自有一份类 A 中方法和属性的复制。当类 D 继承自类 B 和类 C 时，类 D 中就会有两份类 A 的属性和方法（分别通过继承类 B 和类 C 获取）。在这种情况下，当通过类 D 的对象 d 调用函数 f() 时，编译器无法知道调用的是从类 B 继承过来的函数，还是从类 C 继承过来的函数，因此这个调用就有二义性，会导致编译失败。

那么，如何解决这个问题呢？C++ 提供了虚继承的方式来解决，代码如下：

```c++
class B:virtual public A{/*...*/};
class C:virtual public A{/*...*/};
```

通过虚继承的方式，可以保证类 D 中只有一份类 A 的属性和函数的复制，因此可以避免上述介绍的二义性，也就解决了“钻石问题”。

## 什么是虚函数

指向基类的指针在操作它的多态类对象时，会根据不同的类对象调用相应对象的函数，这个函数就是虚函数，虚函数用 virtual 修饰函数名。虚函数的作用是**在程序的运行阶段动态地选择合适的成员函数**，定义了虚函数后，可以在派生类中对虚函数进行重新定义。在派生类中重新定义的函数应与基类的虚函数具有相同的形参个数和形参类型（参数类型的顺序也要一致），以实现统一的接口。如果在派生类中没有对虚函数重新定义，则它继承基类的虚函数。

```c++
#include <iostream>

class A {
public:
  virtual void print() {
    std::cout << "A" << std::endl;
  }
};

class B : public A {
public:
  void print() override {
    std::cout << "B" << std::endl;
  }
};

int main() {
  A a;
  B b;
  A *p1 = &a;
  A *p2 = &b;
  p1->print();
  p2->print();
  return 0;
}
```

```
A
B
```

如果不使用 virtual 修饰函数，那么在上面的代码中，p1 和 p2 都会调用 A 类中的 print() 函数，而不会调用 B 类中的 print() 函数。因此，使用 virtual 修饰函数可以实现多态。

需要注意的是，虚函数虽然非常好用，但是使用虚函数时，并非所有的函数都需要定义成虚函数，因为实现虚函数是有代价的。使用虚函数时，需要注意以下 6 方面的内容。

1. 只需要在声明函数的类体中使用关键字 virtual 将函数声明为虚函数，而定义函数时不需要使用关键字 virtual。

2. 当将基类中的某一成员函数声明为虚函数后，**派生类中的同名函数自动成为虚函数**。

3. 如果声明了某个成员函数为虚函数，则在该类中不能出现与这个成员函数同名并且返回值、参数个数、类型都相同的非虚函数。

4. 非类的成员函数不能定义为虚函数，全局函数以及类的成员函数中静态成员函数和构造函数也不能定义为虚函数，但**可以将析构函数定义为虚函数。**

5. 基类的析构函数应该定义为虚函数，这样在实现多态的时候不会造成内存泄漏。如果基类析构函数未声明为 virtual，当使用基类指针指向派生类时，delete 指针只会调用基类的析构函数，而不会调用派生类的析构函数。如果声明为 virtual，则会先调用派生类的析构函数，再调用基类的析构函数，这样就能够避免内存泄漏。

6. 指针声明不调用构造函数，只有使用 new 创建对象的时候，才会调用构造函数。

虚函数是通过一张虚函数表（Virtual Table）来实现的。该表是一个类的虚函数的地址表，表中保存了虚函数的地址。这样，在有虚函数的类的实例中，此表被分配在实例的内存中，所以当用父类的指针来操作一个子类的时候，这张虚函数表就显得非常重要了，它指明了实际应该调用的函数，如图 1-13 所示。

![](../../assets/images/interview/questions/object/图1-13%20虚函数表的内存布局.png)

对于如下代码：

```c++
A*p=new B();
p->g();
```

由于函数 g 在类 A 和类 B 的虚函数表中的偏移量都是相同的，而且编译器知道这个对象实际是类 B 的对象（因为 p 实际上指向的是类 B 的对象），因此在调用的时候，它就会去 B 的虚函数表中找到函数 g 的地址，从而就可以调用类 B 的函数 g()。如果修改为 A*p=new A();，同理，编译器会去 A 的虚函数表中找到函数 g 的地址完成调用。

C++ 的编译器能够保证虚函数表的指针存在于对象实例中最前面的位置，通过对象实例的地址得到这张虚函数表，然后就可以遍历其中的函数指针，并调用相应的函数。例如，有这样的一个类：

```c++
#include <iostream>

class Base {
public:
  virtual void f() { std::cout << "Base::f()" << std::endl; }
  virtual void g() { std::cout << "Base::g()" << std::endl; }
  virtual void h() { std::cout << "Base::h()" << std::endl; }
};

int main() {
  Base b;
  std::cout << (int *) (&b) << std::endl;
  std::cout << (int *) *(int *) (&b) << std::endl;

  typedef void (*Function)();
  Function pFunction = (Function) * ((int *) *(int *) (&b));
  pFunction();

  return 0;
}
```

预期输出结果如下：

```c++
0x7ffefc5f9a10
0x7ffefc5f9a18
Base::f()
```

实际最后的函数调用奔溃了。

应在构造函数中进行虚函数表的创建和虚函数指针的初始化。根据构造函数的调用顺序，在构造子类对象时，要先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否还有继承者，它初始化父类对象的虚函数表的指针，该虚函数表指针指向父类的虚函数表。执行子类的构造函数时，子类对象的虚函数表指针被初始化，指向自身的虚函数表。

编译器发现一个类中有虚函数，便会立即为此类生成虚函数表，虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针 vptr（对 VC 编译器来说，它插在类的第一个位置上）指向虚函数表。当调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable 关联起来。另外，在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable。这样才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。

## 是否可以把每个函数都声明为虚函数

虽然虚函数很有效，但是不可以把每个函数都声明为虚函数。因为使用虚函数是要付出代价的。由于每个虚函数的对象在内存中都必须维护一个虚函数表，因此在使用虚函数时，尽管带来了使用的方便，却会额外产生一个系统开销。如果仅是一个很小的类，且不想派生其他类，那么根本没必要使用虚函数。

## C++ 如何实现多态

C++ 中通过虚函数实现多态。虚函数的本质就是通过基类指针访问派生类定义的函数。每个含有虚函数的类，其实例对象内部都有一个虚函数表指针。该虚函数表指针被初始化为本类的虚函数表的内存地址。

1. 只有通过指针或者引用调用虚函数才能达到多态的效果，如果通过对象直接调用，就没有多态的效果。

2. 在基类的构造和析构函数中调用虚函数，没有多态性。因为在构造一个子类的对象时，会先调用基类的构造函数，此时子类没有完成构造，还没有初始化，如果此时在基类的构造函数中调用虚函数，如果可以，就是调用一个还没有被初始化的对象，这是很危险的行为，有些编译器会对此进行如下设计：在这种情况下默认调用父类的函数（具体的实现与编译器有关）。所以，C++ 中最好不在父类的构造函数中调用虚函数。

## 纯虚函数指的是什么

由于在很多情况下，基类中不能对虚函数给出有意义的实现，只能把函数的实现留给派生类。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但是动物本身生成对象不合情理，此时就可以将动物类中的函数定义为纯虚函数，如果基类中有纯虚函数，那么在子类中必须实现这个纯虚函数，否则子类将无法被实例化，也无法实现多态。

含有纯虚函数的类称为抽象类，抽象类不能生成对象。纯虚函数永远不会被调用，它们主要用来统一管理子类对象。

```c++
#include <iostream>

class Animal {
public:
  virtual void speak() = 0;
};

class Dog : public Animal {
public:
  void speak() override { std::cout << "Woof!" << std::endl; }
};

class Labrador : public Dog {
public:
  Labrador() { std::cout << "New labrador" << std::endl; }
  void speak() override { std::cout << "Woof! Woof!" << std::endl; }
};

class Cat : public Animal {
public:
  void speak() override { std::cout << "Meow!" << std::endl; }
};

int main() {
  Animal *animals[3];

  animals[0] = new Labrador();
  animals[1] = new Cat();
  animals[2] = new Dog();

  for (int i = 0; i < 3; i++) {
    animals[i]->speak();
  }

  return 0;
}
```

## 什么函数不能声明为虚函数

1. 只有类的成员函数才能被声明为虚函数。

2. 静态成员函数不能为虚函数，因为调用静态成员函数属于类，而不属于对象，但调用虚函数需要从一个实例中指向虚函数表的指针，以得到函数的地址，因此调用虚函数需要一个实例化的对象，两者相互矛盾。

3. 内联函数不能为虚函数。

4. 构造函数不能为虚函数。

5. 析构函数可以为虚函数，而且通常声明为虚函数。

构造函数不能是虚函数，因为构造函数是在对象完全构造之前运行的。换句话说，运行构造函数前，对象还没有生成，更谈不上动态类型了。构造函数是初始化虚表指针，而虚函数放到虚表里面，当要调用虚函数的时候首先要知道虚表指针，这就存在矛盾的地方了，所以，构造函数不可能是虚函数。构造函数虽然不能是虚函数，但构造函数里可以调用虚函数，这种调用会失去多态的特性。

```c++
#include <iostream>

class Base {
public:
  Base() {
    std::cout << "Base constructor" << std::endl;
    foo();
  }
  virtual ~Base() { std::cout << "Base destructor" << std::endl; }
  virtual void foo() { std::cout << "Base::foo()" << std::endl; }
};

class Derived : public Base {
public:
  Derived() { std::cout << "Derived constructor" << std::endl; }
  ~Derived() { std::cout << "Derived destructor" << std::endl; }
  void foo() { std::cout << "Derived::foo()" << std::endl; }
};

int main() {
  Base *b = new Derived();
  b->foo();
  delete b;
  return 0;
}
```

```
Base constructor
Base::foo()
Derived constructor
Derived::foo()
Derived destructor
Base destructor
```

基类的指针生成了一个派生类对象，将会隐式调用 base 的构造函数，尽管对象是 Derived，但构造基类部分时，子类的对象还没有生成，所以会调用基类的虚函数 f()。在调用 p->f() ;的时候，由于子类的对象已经被创建出来了，此时就会调用子类的函数 f()。

析构函数可以是虚函数，而且有的时候是必需的，基类指针指向派生类，用基类指针 delete 时，如果不定义成虚函数，派生类的析构函数将无法被调用。

析构函数执行时先调用派生类的析构函数，然后才调用基类的析构函数。如果析构函数不是虚函数，而程序执行时又要通过基类的指针去销毁派生类的动态对象，那么用 delete 销毁对象时，只调用了基类的析构函数，未调用派生类的析构函数。这样会造成销毁对象不完全，如果派生类的析构函数中需要释放在构造函数中申请的空间，当子类的析构函数没有被调用时，内存也就没有被释放。

## C++ 中如何阻止一个类被实例化

前面的章节中已经介绍过可以通过把类的构造函数声明为 private 来阻止一个类被实例化。除此之外，还可以通过把类定义为抽象类的方法来阻止类被实例化（在类中声明纯虚函数）。抽象类之所以不能被实例化，是因为抽象类不能代表一类具体的事物，它是对多种具有相似性的具体事物的共同特征的一种抽象。

## 二级

```c++

```
