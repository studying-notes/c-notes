---
date: 2022-10-30T13:51:12+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "STL 容器"  # 文章标题
url:  "posts/cpp/interview/language/stl"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## 什么是泛型编程

泛型编程（Generic Programming）的目的是为了发明一种语言机制，能够帮助实现一个通用的标准容器库。通用的标准容器库是指能够实现这样一种功能：例如，用一个 List 类存放所有可能类型的对象，而泛型编程可以让程序员编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。泛型与模板类似，指具有在多种数据类型上皆可操作的含义。

STL 巨大，而且可以扩充，它包含很多计算机基本算法和数据结构，而且将算法与数据结构完全分离，其中，算法是泛型的，不与任何特定数据结构或对象类型联系在一起。

## vector 与 list 的区别有哪些

vector 为存储的对象分配一块连续的地址空间，对 vector 中的元素随机访问效率很高。在 vector 中插入或者删除某个元素，需要将现有元素进行复制、移动。如果 vector 中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector 的效率优于 list。vector 在每次扩张容量的时候，将容量扩展 2 倍，这样对于小对象来说，效率是很高的。

list 表示非连续的内存区域，并通过一对指向首尾元素的指针双向链接起来，从而允许向前和向后两个方向进行遍历，list 中的对象是离散存储的。在 list 的任意位置插入与删除元素的效率都很高，指针必须被重新赋值，但是不需要用拷贝元素来实现移动。它对随机访问的支持并不好，访问一个元素需要遍历中间的元素，另外，每个元素还有两个指针的额外空间开销，随机访问某个元素需要遍历 list。在 list 中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针即可。

vector 内部使用顺序存储，访问速度快，但是删除数据比较耗费性能。list 内部使用链式存储，访问速度慢，但是删除数据比较快。

在使用容器的时候，一般应遵循下面的原则：

1. 需要高效的随机存取，而不在乎插入和删除的效率，使用 vector。

2. 需要大量的插入和删除，而不关心随机存取，则应使用 list。

3. 需要随机存取，而且关心两端数据的插入和删除，则应使用 deque。

## 实现循环队列

在队列的顺序存储结构中，除了使用一组地址连续的存储单元依次存放从队列头到队列尾的元素外，还需要另外设置 front 和 rear 两个指针，分别指示队列头元素以及队列尾元素的位置。初始化建空队列时，令 `front = rear = 0`，每当插入新的队列尾元素时，“尾指针增 1”，而每当删除队列头元素时，则执行“头指针增 1”。因此，在非空队列中，头指针始终指向队列头元素，尾指针始终指向队列尾元素的下一个位置。

为充分利用向量空间，克服“假溢出”现象的方法是：将向量空间想像为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列 (Circular Queue)。循环队列中，由于入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针，造成队空和队满时头尾指针均相等。因此，无法通过条件 `front == rear` 来判别队列是“空”，还是“满”。

解决这个问题的方法至少有两种：

1. 另外设置一个标志位来区别队列是“空”，还是“满”。

2. 少用一个元素空间，约定以“队列头指针在队列尾指针的下一位置（指环状的下一位置）”上作为队列呈“满”状态的标志。队满时：`(rear+1)%n = front`，n 为队列长度（所用数组大小），由于 rear、front 均为所用空间的指针，循环只是逻辑上的循环，所以需要求余运算。

```c++
const int MAX_SIZE = 1000;

typedef struct {
  int elements[MAX_SIZE];
  int front, rear;
} CircularQueue;

int IsEmpty(CircularQueue *queue) {
  return queue->front == queue->rear;
}

int isFull(CircularQueue *queue) {
  return (queue->rear + 1) % MAX_SIZE == queue->front;
}

int EnQueue(CircularQueue *queue, int element) {
  if (isFull(queue))
    return 0;
  queue->elements[queue->rear] = element;
  queue->rear = (queue->rear + 1) % MAX_SIZE;
  return 1;
}

int DeQueue(CircularQueue *queue, int &element) {
  if (IsEmpty(queue))
    return 0;
  element = queue->elements[queue->front];
  queue->front = (queue->front + 1) & MAX_SIZE;
  return 1;
}
```

## 用两个栈模拟队列操作

题目要求用两个栈来模拟队列，栈 A 与栈 B 模拟队列 Q，A 为插入栈，B 为弹出栈，以实现队列 Q。假设 A 和 B 都为空，可以认为栈 A 提供入队列的功能，栈 B 提供出队列的功能。入队列：入栈 A。

出队列分两种情况考虑：

1. 如果栈 B 不为空，则直接弹出栈 B 的数据。

2. 如果栈 B 为空，则依次弹出栈 A 的数据，放入栈 B 中，再弹出栈 B 的数据。

## 用两个队列实现栈

可以采用以下方法实现，入栈：所有元素依次入队列 q1。例如，将 A、B、C、D 四个元素入栈，从队列尾部到队列首部依次为 D、C、B、A，出栈的时候判断栈元素个数是否为 1，如果为 1，则队列 q1 出列；如果不为 1，则队列 q1 中所有元素出队列，入队列 q2，最后一个元素不入队列 q2，把这个元素出队列（这个元素就是出栈得到的元素），接着把队列中 q2 所有元素入队列 q1。例如，将 D、C、B、A 出队列，C、B、A 入队列 q2，然后 D 出队列，最后把 C、B、A 再返回到队列 q1 中，实现了后进先出。

```c++

```
