---
date: 2022-10-27 16:26:31+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "变量"  # 文章标题
url:  "posts/cpp/interview/language/variable"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## 简介

变量是一段有名字的连续存储空间，它是程序中数据的临时存放场所。

## 全局变量和静态变量有什么异同

全局变量的作用域是整个程序，它只需要在一个源文件中定义，就可以作用于所有的源文件，其他不包含全局变量定义的源文件都需要用 extern 关键字再次声明这个全局变量。若某一个局部重新定义了这个变量，则全局变量作用域是除了这个局部外的整个程序，它的生命期与程序生命期一样长。

全局变量、静态局部变量与静态全局变量都在**静态存储区**分配空间，而局部变量在栈上分配空间。

静态变量存储在静态存储区，它的生命期与程序生命期相同。例如，某一个子程序（子函数）定义了一个静态变量，当程序退出该子程序时，这个量仍被保留，其他非静态变量的存储单元被释放。也就是说，非静态变量的生命期与子程序的生命期相同，进入子程序，分配单元，退出则回收。下次调用子程序时非静态变量消失，静态变量却保留上次调用的结果。

总的来说，它们的相同点是都保留在静态存储区，生命期与程序生命期相同。而不同点在于，**全局变量具有全局作用域，静态变量具有文件作用域**。

静态变量包含静态局部变量和静态全局变量。静态局部变量具有局部作用域，只被初始化一次，自从第一次被初始化，直到程序运行结束都一直存在。它和全局变量的区别在于，全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。静态全局变量也具有全局作用域，它与全局变量的区别在于，如果程序包含多个文件，它作用于定义它的文件里，不能作用到其他文件里，即被 static 关键字修饰过的变量具有文件作用域，这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期；把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。

## 局部变量需要“避讳”全局变量吗

局部变量可以与全局变量重名，但是局部变量会屏蔽全局变量。要使用全局变量，需要使用操作符 ::。在函数内引用变量会用到同名的局部变量，而不会使用到全局变量，对于有些编译器，在同一个函数内可以定义多个同名的局部变量。例如，在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。

具体来说，全局变量与局部变量的区别有以下 4 个方面：

1. 全局变量的作用域为程序块，而局部变量的作用域为当前函数。

2. 内存存储方式不同，全局变量分配在全局数据区，后者分配在栈区。

3. 生命周期不同。全局变量随主程序创建而创建，随主程序销毁而销毁，局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在了。

4. 使用方式不同。通过声明为全局变量，程序的各个部分都可以用到，而局部变量只能在局部使用。

但是需要注意的是，局部变量不可以赋值为同名全局变量。

```c++
#include <iostream>

int i = 1;

int main() {
  int j = i;
  std::cout << j << std::endl;

  int i = i;
  std::cout << i << std::endl;
  return 0;
}
```

```
1
0
```

实上述代码合法，编译也能通过，但是不合理，int i = i，i 变量从声明的那一刻开始就是可见的，main() 函数里的 i 不是 1，因为它和 main() 函数外的 i 无关，而是一个未定义值。

## 如何建立和理解非常复杂的声明

1. 一个整型数。

```c++
int i;
```

2. 一个指向整型数的指针。

```c++
int *p;
```

3. 一个指向指针的指针，它指向的指针是指向一个整型数。

```c++
int **pp;
```

4. 一个有 10 个整型数的数组。

```c++
int a[10];
```

5. 一个有 10 个指针的数组，数组中指针指向一个整型数。

```c++
int *a[10];
```

6. 一个指向有 10 个整型数数组的指针。

```c++
int (*p)[10];
```

7. 一个指向函数的指针，该函数有一个整型参数并返回一个整型数。

```c++
int (*p)(int);
```

8. 一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数。

```c++
int (*a[10])(int);
```

为了更好地说明上述问题，以如下两个声明为例：

其实，在 C 语言中，每个变量声明都由两个部分组成：一个类型和一组具有特定格式的，期望用来对该类型求值的表达式。

例如，`float*g( ),(*h)( )`，该语句表示 `*g( )` 和 `(*h)( )` 都是 float 表达式。由于 `()` 比 `*` 优先级更高，绑定得更紧密，所以 `*g()` 与 `*(g())` 表示的意义相同，即 g 是一个返回 float 指针的函数，而 h 是一个指向返回 float 的函数的指针。

除了上述提及的一些函数声明方式外，还有一些声明方式非常复杂，如 `(*(void(*)( ))0)( )`，该声明表示硬件会调用地址为 0 处的子程序，但如果写成是 `(*0)( )` 并不符合要求，因为 `*` 运算符要求必须有一个指针作为它的操作数，而不能是数字。而且，这个操作数必须是一个指向函数的指针，以保证 `*` 的结果可以被调用，所以此时需要将 0 转换为一个可以描述“指向一个返回 void 的函数的指针”的类型，即 `(void(*)( ))0`。

### `void*(*(*fp1)(int))[10];`

为了便于理解，将其分解为如下两个表达式：

```c++
p=(*fp1)(int)
void*(*p)[10]
```

第一个表达式可以与上面讲解的 7 对应，fp1 是一个函数的指针，这个函数的参数为 int，函数的返回值为 p。

第二个表达式与上面讲解的 6 对应，由此可以看出 p 是一个指向有 10 个元素的数组的指针，这个数组中元素的类型为 void *（指向 void 指针）。

综上所述，fp1 是一个函数的指针，它指向的函数有一个 int 参数，这个函数的返回值是一个指针，这个指针指向一个有 10 个元素的数组，而且数组中的每个元素都是 void *。

### `float (*(*fp2)(int,int,int))(int);`

为了便于理解，将其分解为如下两个表达式：

```c++
p=(*fp2)(int,int,int)
float (*p)(int);
```

由第一个表达式可以看出：fp2 是一个指针，这个指针指向一个函数，这个函数有 3 个 int 类型的参数，这个函数的返回值为 p ；从第二个表达式可以看出 p 也是一个指针，这个指针指向一个函数，并且这个函数的参数为 int，返回值为 float。

综上所述，fp2 是一个指向函数的指针，函数有 3 个 int 类型的参数，函数的返回值是一个函数的指针（这个函数的参数为 int，返回值为 float）。

### `int (*(*fp3)())[10]();`

fp3 是一个指向函数的指针，这个函数的参数为空，函数的返回值也是一个指针（这个指针指向一个有 10 个元素的数组，数组中的每个元素是一个指针，这个指针指向一个函数，这个函数的参数为空，函数的返回值是 int 型）

## 变量定义与变量声明有什么区别

任何变量在使用前都需要进行定义或声明，**定义（definition）为变量分配存储空间，还可以为变量指定初始值。**在一个程序中，变量有且仅有一个定义。例如，`int my_array[100]`，而**声明（declaration）是指向程序表明变量的类型和名字。**

**定义也是声明**，当定义变量时声明了它的类型和名字。可以通过使用 extern 关键字声明变量名而不定义它，它所说明的并非自身，而是描述其他地方创建的对象，可以多次出现，如 `extern int my_array[]`。

如果程序前面都没有出现过 a 这个变量，这时要使用 a，就必须让程序知道要使用 a 这个变量，这时候写入 int a，以前没有 a 这个变量的，现在程序为了记住它，就得为它分配空间，于是这是一个定义。如果程序包含的其他文件里已经出现过 a 了，这证明程序已经为 a 分配内存，这时如果要使用 a，只需要通过 extern int a 告诉程序，这个 a 在其他地方定义过即可。

“定义也是声明”，这说明定义包括声明，对于 `int a` 来说，它既是定义，又是声明，对于 `extern int a` 来说，它是声明，不是定义。**一般为了叙述方便，把申请存储空间的声明称为定义，而把不申请存储空间的声明称为声明。**

## 不使用第三方变量，如何交换两个变量的值

算术法

```c
a = a + b;
b = a - b;
a = a - b;
```

位运算法

```c
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

## C 与 C++ 变量初始化有什么不同

在 C 语言中，只能用常数对全局变量和静态变量进行初始化，否则编译器会报错。在 C 语言里，全局变量如果不进行初始化，其默认值为 0。C 语言中静态变量和全局变量（extern 外部变量属于全局变量）的分配内存空间和初始化是在编译阶段完成的，而其他变量是在编译阶段进行内存空间分配、在程序运行时才赋予初值的。

而在 C++ 语言中，如果在一个文件中定义了 int a = 5，要在另一个文件中定义 int b = a，前面必须对 a 进行声明：extern int a，否则编译不通过，即使是 int b = a，这句话也是分两步进行的：在编译阶段，编译器把 b 当作是未初始化数据而将它初始化为 0 ；在执行阶段，在 main 函数被执行前有一个全局对象的构造过程，int b = a，被当作是 int 型对象 b 的复制初始化构造来执行。

在 C++ 语言中，全局对象、变量的初始化是独立的，如果不是像 int a = 5 这样的已初始化数据，那么就是像 b 这样的未初始化数据。而 C++ 中全局对象、变量的构造函数调用顺序是跟声明有一定关系的，即在同一个文件中先声明的先调用。对于不同文件中的全局对象、变量，它们的构造函数调用顺序是未定义的，取决于具体的编译器，不同的编译器、连接器，结果都可能不同，另外，连接时，指定.obj 文件的顺序也有关系。

## C 语言中各种变量的默认初始值是什么

全局变量放在内存的全局数据区，由编译器建立，如果在定义的时候不做初始化，则系统将自动为其初始化，数值型为 0，字符型为 NULL，即 0，指针变量也被赋值为 NULL。静态变量的情况与全局变量类似。而非静态局部变量如果不显式初始化，那么其内容是不可预料的，将是随机数，会很危险，对系统造成非常大的安全隐患。

## 类型转换

在 C/C++ 中，常用的数据类型有 char、uchar、short、ushort、int、uint、long、ulong、float 和 double。这些数据类型所能表示的范围也是不同的。那么，当这些不同的数据类型参与运算的时候，就带来了类型转换问题。

### 算术转换过程中的类型转换

当参与运算的表达式中有不同的数据类型的时候，在运算的过程中会进行类型隐式转换，这个转换过程主要遵循如下 3 条规则：

1. 整数提升。也就是说，如果参与运算的表达式中没有比 int 更高的类型，那么，参与运算的表达式都会隐式转换为 int，然后进行运算。

2. 类型对齐。也就是说把所有参与运算的表达式隐式转换为占用空间最大的数据类型。例如：在 64 位机器上，short 占用 2 个字节，long 占用 8 个字节。那么，当表达式中既有 short，又有 long 的时候，short 类型的表达式就会隐式转换为 long。

3. 当无符号数与有符号数类型进行混合运算时，有符号数会隐式转换为无符号数。需要注意的是，这个转换过程可能会导致错误的出现。

通过以上分析，可以总结出类型隐式转化的规则如下：

```c++
(char, uchar, short, ushort)->int->uint->long->ulong->float->double
```

例如：

```c++
#include <iostream>

int main() {
  char c = 1;
  int i = 2;
  long l = 3;
  unsigned long ul = 4;
  auto r = c + i + l + ul;
  std::cout << std::boolalpha << (typeid(ul) == typeid(unsigned long)) << std::endl;
  return 0;
}
```

这个表达式的运算过程为：c 首先会被隐式转换为 int 类型，然后运行 c+i，运行结果为 int 类型，接着运算 +l 的时候会隐式转换为 long 类型，最后运算 ul 的时候会隐式转换为 unsigned long 类型，因此这个表达式的运算结果的类型为 unsigned long。

### 赋值运算过程中的类型转换

1. 普通的两个变量赋值（以左值为准）。

2. 函数参数的传递，其实也就是把实参的值赋给形参（以形参的类型为准）。

3. 赋值运算，其实就是将函数运算的结果赋值给返回值（以返回值类型为准）。

```c++

```
