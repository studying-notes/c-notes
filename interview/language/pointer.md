---
date: 2022-10-26 09:23:14+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "指针"  # 文章标题
url:  "posts/cpp/interview/language/pointer"  # 设置网页永久链接
tags: [ "C", "C++" ]  # 标签
series: [ "C 学习笔记" ]  # 系列
categories: [ "学习笔记" ]  # 分类

toc: true  # 目录
draft: false  # 草稿
---

## 使用指针有哪些好处

指针与其他类型变量一样，不同之处在于，一般的变量包含的是实际的真实数据，而指针包含的是一个指向内存中某个位置的地址。一般而言，使用指针有以下 5 个方面的好处：

1. 可以动态分配内存，由于可以直接操作内存，所以运行效率更高。

2. 能写出简洁、高效的代码。

3. 为动态数据结构，尤其是树和链表，提供支持。

4. 可以写出更加复杂、灵活的数据结构。

5. 高效地按引用“复制”数组与结构，特别是作为函数参数的时候，可以按照引用传递函数参数，提高开发效率。

## 引用还是指针

**引用其实就是别名的意思**，它用于**定义一个变量来共享另一个变量的内存空间**，**变量是一个内存空间的名字**，如果给内存空间起另外一个名字，那就能够共享这个内存了。

指针指向另一个内存空间的变量，可以通过它来**索引另一个内存空间的内容**，而指针本身也有自己的内存空间。

引用与指针有着相同的地方，即指针指向一块内存，它的内容是所指内存的地址，引用是某块内存的别名。但是，两者并非完全相同，它们之间也存在着差别，具体表现在以下 8 个方面的内容：

1. 从本质上讲，指针是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，即其指向的地址可以被改变，其指向的地址中存放的数据也可以被改变。而引用则只是一个别名而已，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且引用的对象在其整个生命周期中是不能被改变的，即自始至终只能依附于同一个变量，具有“从一而终”的特性。

2. 当作为参数传递时，两者不同。在 C++ 语言中，指针与引用都可以用于函数的参数传递，但是指针传递参数和引用传递参数有着本质的不同。**指针传递参数本质上是值传递的方式，它所传递的是一个地址值。**值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。**值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值**（这里的实参与形参是指指针的值（一个地址），对形参地址值的修改不会改变实参地址的值。但是，由于形参与实参都指向同一块内存空间，因此通过形参修改它所指向内存空间的值对实参是可见的）。而在引用传递过程中，被调函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。

3. 引用使用时不需要解引用（*），而指针需要解引用。

4. 引用只能在定义时被初始化一次，之后不能被改变，即引用具有“从一而终”的特性。而指针却是可变的。

```c++
int a = 10;
int &b = a; // b是a的引用
int *p = &a; // p是a的指针
```

5. 引用不可以为空，而指针可以为空。引用必须与存储单元相对应，一个引用对应一个存储单元。

6. 对引用进行 sizeof 操作得到的是所指向的变量（对象）的大小，而对指针进行 sizeof 操作得到的是指针本身（所指向的变量或对象的地址）的大小，typeid(T) == typeid(T & ) 恒为真，sizeof(T) == sizeof(T & ) 恒为真，但是当引用作为成员时，其占用空间与指针相同。

7. 指针和引用的自增 (++) 运算意义不一样。

```c++
int a = 10;
int &b = a;
int *p = &a;
b++; // a = 11
p++; // p指向下一个存储单元
(*p)++; // a = 12
```

8. 如果返回动态分配的对象或内存，必须使用指针，引用可能引起内存泄漏。

由于引用与指针的区别，所以并非所有使用指针的地方都可以使用引用，也并非所有使用引用的地方都可以使用指针，两者的使用也有其特定的环境。

以如下实例为例进行分析。

```c++
int *a; int *&p=a;
int b=8; p=&b;
// 正确，指针变量的引用
```

```c++
void &a =3;
// 错误，没有变量或对象的类型为void
```

```c++
int &ri=NULL
// 错误，不能将NULL赋给引用
```

```c++
int & ra=int;
// 错误，不能用类型名作为引用的初始值
```

```c++
int *p=new int;
int &r=*p;
// 正确，指针变量的引用
```

```c++
int &b[10];
// 错误，引用不能作为数组的元素
```

```c++
int & *p;
// 错误，不能建立指向引用的指针
```

```c++
int &&r;
// 错误，不能建立引用的引用
```

当使用 & 运算符取一个引用的地址时，其值为所引用变量的地址。

## 指针和数组是否表示同一概念

指针可以随时指向任意类型的内存块，而数组可以在静态存储区被创建。例如，全局数组可以在栈上被创建。从原理与定义上看，虽然指针与数组表示的是不同的概念，但指针却可以方便地访问数组或者模拟数组，两者存在着一种貌似等价的关系，但也存在着诸多不同之处，主要表现在以下两个方面：

### 修改内容不同

例如，`char a[]=“hello”`，可以通过取下标的方式对其元素值进行修改。例如，`a[0]=‘X’` 是正确的，而对于 `char*p=“world”`，此时p 指向常量字符串，所以 `p[0]=‘X’` 是不允许的，编译会报错。

### 所占字节数不同

例如，`char*p=“world”`，p 为指针，则 sizeof(p) 得到的是一个指针变量的字节数，而不是 p 所指的内存容量。C/C++ 语言没有办法知道指针所指的内存容量，除非在申请内存时标记出来。但是对于数组来讲，可以通过 sizeof 操作符来计算数组的大小。

在 32 位机器上，sizeof(a) = 12 字节，而 sizeof(p) = 4 字节。

但需要注意的是，当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。

此时 sizeof(a) = sizeof(int) = 4，而不是 sizeof(int) * 100 = 400。

## 指针是否可进行 >、<、>=、<=、== 运算

可以。由于指针的值是变量的地址，从本质上来讲，它就是表示内存地址的一个长整数。既然是整数，当然可以进行上面所有的运算。例如：指向同一个数组中元素的两个指针，通过比较大小就能确定两个指针的前后位置关系，也可以通过两个指针的差来确定它们之间的距离。一般来讲，也只有当两个指针指向同一数组元素的时候，才有可能作指针比较。对于其他的指针变量而言，比较大小是没有意义的。

## 指针与数字相加的结果是什么

指针与数字相加的结果是`指针所指向的地址` + `数字*类型大小`。

```c++
#include <iostream>

int main() {
  int a = 10;
  int *p = &a;
  std::cout << p << std::endl;
  p++;
  std::cout << p << std::endl;

  return 0;
}
```

```
0x2b59fffbdc
0x2b59fffbe0
```

内存地址偏移了 4 个字节，因为 int 类型占 4 个字节。

## 野指针和空指针

### 野指针

野指针是指**指向不可用内存的指针**。一般来讲，主要有下面 3 种情况会出现野指针：

1. 任何指针变量在被创建时，不会自动成为 NULL 指针（空指针），**其默认值是随机的**，所以**指针变量在创建的同时应当被初始化，或者将指针设置为 NULL**，或者让它指向合法的内存，而**不应该放之不理，否则就会成为野指针**。

2. 当指针被释放 free/delete 后，未能将其设置为 NULL，也会导致该指针变为野指针。虽然 free 和 delete 把指针所指的内存给释放掉了，但它们并没有把指针本身释放掉，所以建议在调用 free 或 delete 释放掉指针所指向的空间后也把指针变量设置为 NULL，这样就能避免野指针的出现。

3. 指针操作超越了变量的作用范围。例如，返回栈内存的指针，当函数调用结束后栈内存就会被释放，此时返回的指针也就成了野指针了。

### 空指针

空指针是一个特殊的指针，也是唯一一个对任何指针类型都合法的指针。指针变量具有空指针值，表示它当时处于闲置状态，没有指向有意义的内容。为了提高程序的可读性，标准库定义了一个与 0 等价的符号常量 NULL，对于指针 p 而言，程序里可以写 p = 0 或者 p = NULL，两种写法都把 p 置为空指针值。C 语言保证这个值不会是任何对象的地址。给指针值赋零则使它不再指向任何有意义的东西。

## 不使用 sizeof，如何求 int 占用的字节数

其指针指向的地址+1得到下一个地址，两者之差为它所占的字节数。

```c++

```
