---
date: 2022-01-31T12:07:57+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "第8章_数组与指针"  # 文章标题
# description: "文章描述"
url:  "posts/cpp/docs/[Linux]C/第8章_数组与指针"  # 设置网页永久链接
tags: [ "cpp" ]  # 标签
series: [ "C/C++ 学习笔记"]  # 文章主题/文章系列
categories: [ "学习笔记"]  # 文章分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

数组与指针涉及数据在内存中的存储位置问题。数组由连续的存储单元组成，最低地址对应于数组的第一个单元，最高地址对应于数组的最后一个单元。指针是一种特殊的变量，该变量所存放的是内存的地址，通过指针变量可访问所指向内存空间中的内容。

## 一维数组

数组是一组相关的内存位置，它们都具有相同的名称和类型。引用数组中的特定位置或元素，需要指定数组的名称和数组中特定的元素的位置编号，该编号即是数组下标。一维数组是只使用一组下标表示的数组

### 一维数组的一般形式

维数组的一般声明形式为

```c++
数据类型 数组名[长度];
```

其中，长度必须是常量表达式，数组名与其他变量名称一样，只能包含字母、数字和下划线，且不能以数字字符开始。如下列源代码，声明 10 个元素的字符型数组。

```c++
//声明数组 c，类型为字符型，长度为 10
char c[10];
```

该数组的第一个元素的为 c[0]，第 n 个元素下为 c[n-1]。为数组初始化有 3 种方式。

```c++
int main() {
    char c[10];
    // 1 声明循环控制变量
    for (int i = 0; i < 10; i++) {
        c[i] = 0;
    }
    
    //2 声明数组并初始化
    char d[10]={1,2,3,4,5,6,7,8,9,0};

    //声明数组并初始化为0
    char e[10]={0};

    // 3 不指定长度，根据初始值个数决定
    char f[]={1,2,3,4,5,6,7,8,9,0};

    return 0;
}
```

声明后，数组元素顺序存放于内存中，假设起始地址为 3001，则每个数组元素依次加 1，如图 8.1 所示。

![](../assets/images/图8.1_数组在内存中存放的位置示意图.png)

使用数组时，可通过数组下标引用每个数组元素。如下例，使用选择排序法对数据的元素进行从小到大排序。

```c++
#include <stdio.h>
#include <stdlib.h>


int main() {
    int a[10];
    int i, j;
    int t;

    printf("before: \n");

    for (i = 0; i < 10; i++) {
        a[i] = rand() % 100 + 1;
        printf("%4d", a[i]);
    }

    printf("\n\nafter: \n");

    for (i = 0; i < 9; i++) {
        for (j = i + 1; j < 10; j++) {
            if (a[i] > a[j]) {
                t = a[i];
                a[i] = a[j];
                a[j] = t;
            }
        }
    }

    for (i = 0; i < 10; i++) {
        printf("%4d", a[i]);
    }

    return 0;
}
```

### 字符串使用的一维数组

字符型数组可以存放字符串数据，**字符串数组**与一般的**字符数组**的区别是字符串数组包含字符串结東符“\0”，该符号的 ASCII 码值为 0。因此，**字符串一维数组的长度要比实际字符串的长度多 1 元素**，如下例所示。

```c++
char c1[] = {'C', 'h', 'i', 'n', 'a'};
char c2[] = "China";
```

数组 c1 是字符数组，c2 是字符串数组，它们在内存中所占用的空间如图 8.2 所示

![](../assets/images/图8.2_字符数组与字符串数组在内存中所占用的空间.png)

C 语言并没有将字符串作为独立的数据类型，但允许使用字符串常量和字符串数组，并在标准函数库里提供了一些常用的字符串操作函数。最常用的字符串操作函数见表8.1。

![](../assets/images/表8.1_最常用的字符串操作函数.png)

```c++
#include <stdio.h>
#include <string.h>


int main() {
    // strlen() counts characters until it hits a null character.
    char c1[] = {'A', 'B', 'C', 'D', 'E', '\0'};
    char c2[] = "ABCDE";

    printf("%lu\n", sizeof(char));
    printf("%lu\n", strlen(c1));
    printf("%lu\n", strlen(c2));

    return 0;
}
```

只有包含字符串结束符的数组才被认为是字符串数组，字符数组则不能被函数当作字符串操作。

## 二维数组

C语言允许使用多维数组，即使用多组下标的数组。二维数组是最常用的多维数组。多维数组在内存中存放数据的顺序与一维数组相同，使用连续的存储单元。

### 二维数组的一般形式

```c++
数据类型 数组名[长度1][长度2]；
```

数组的总长度等于长度 1 与长度 2 的乘积。如下列源代码所示：

```c++
//声明二维数组并初始化，数组总长度为10
char c[2][5] = {63, 64, 65, 66, 67, 68, 69, 70, 71, 72};
```

该语句声明了一个拥有 10 个存储单元的字符型数组，在内存中的位置如图 8.3 所示。在实际应用中，可将二维数组理解为一个表格，第一组下标为表格的行数，第二组下标为表格的列数。每组下标以 0 开始，最后一个元素的下标数值为长度减 1。

![](../assets/images/图8.3_二维数组在内存中存取的位置示意图.png)

引用数组边界之外的元素将造成程序运行错误。数组初始值列表中提供的初始值多于数组元素数量、使用变量作为数组长度声明数组都将引起编译错误。

### 二维字符串数组

维字符串数组可以看作是多个一维字符串数组，第 1 组下标长度即存放的字符串个数，第 2 组下标长度是可存放的最长的字符串长度加 1。当使用标准函数库中的字符串函数处理二维字符串数组时，必须给出第一组下标，每次只能处理其中一个字符串，如下列源代码所示。

```c++
#include <stdio.h>
#include <string.h>


int main() {
    // https://stackoverflow.com/questions/16877264/c-c-printf-before-scanf-issue
    // 不关闭缓存可能 printf 直到最后才输出到控制台
    setbuf(stdout, NULL);

    char buddy[3][200];
    int i;

    printf("Name: ");
    scanf("%50s", buddy[0]);

    printf("Phone: ");
    scanf("%30s", buddy[1]);

    printf("Address: ");
    scanf("%199s", buddy[2]);

    printf("Info: \n");

    for (i = 0; i < 3; i++) {
        printf("%s\n", buddy[i]);
    }

    return 0;
}
```

示例中声明了一个长度为 600 的二维字符串数组，该数组最后一组下标的长度为 200，所以能存放的字符串长度最长为 199。使用 scanf和 printf 函数处理字符串数组时，要省略最后一组下标，这样能得到所要处理的字符串的首地址，字符串处理函数会在遇到字符串结束符时停止处理，忽略字符串结束符后的存储单元。scanf（）函数会为输入的字符串加上字符串结束符。当输入的字符串长度超过格式控制符所指定的长度时，scan0 函数将自动根据指定长度裁剪。但如果格式控制符没有指定长度，则会窜入下一行，造成逻辑错误。

### 多维数组

多维数组是指拥有多组下标的数组，维数的限制由具体编译器决定。多维数组的一般声明形式为

```c++
数据类型 数组名[长度1][长度21……[长度n]；
```

数组的总长度等于每组下标长度的乘积。多维数组使用连续的存储空间。

由于大量占用内存的关系，三维数组以上的多维数组较少使用。计算机要花大量的时间计算数组的下标，这意味着存取多维数组的元素要比存取一维数组的元素花更多时间由于这些原因，多维数组通常借助指针当作一维数组使用。

## 指针与指针变量

在程序中声明变量后，编译器就会为该变量分配相应的内存单元。也就是说，每个变量在内存中会有固定的位置，有具体的地址。由于变量的数据类型不同，它所占的内存单元数也不相同。

在程序编译时，编译器将指定这些变量和数组所需要的存储空间长度。程序运行中，则由操作系统为这些变量和数组分配内存单元。整型变量所占用的内存为2字节，长度为5的字符型数组所占用的内存为5字节，单精度浮点型变量所占用的内存为4字节，双精度浮点型所占用的内存为8字节。由于计算机内存是最小的寻址单位是字节，设变量的存放从内存3000单元开始，则操作系统为这些变量和数组分配内存单元，如图8.4所示。

![](../assets/images/图8.4_变量和数组内存分配示意图.png)

变量在内存中按照数据类型的不同所占内存的大小也不同，每个变量都有具体的内存单元地址。如变量i在内存的地址是3000，占据2个字节后，数组c的内存首地址就为302，变量f的内存地址为3008等。

一个地址唯一指向一个内存变量，称这个地址为变量的指针。如果将变量的地址保存在内存的特定区域，用变量来存放这些地址，这样的变量就是指针变量，通过指针对所指向变量的访问，也就是一种对变量的间接访问。

假设一组指针变量 pi、pc、pf 和 pd 分别指向上述的变量或数组 i、c[]、f 和 d，指针变量也同样被存放在内存，二者的关系如图 8.5 所示。指针变量的存储空间中存放的数据为对应变量或数组的内存地址，通过该地址就可以访问对应的变量或数组。

![](../assets/images/图8.5_指针变量与所指变量的映射关系.png)

## 指针变量的定义与引用

指针变量是包含内存地址的变量。一般的变量直接包含一个特定的值，而指针变量包含的是某一特定数据类型的内存地址。普通变量直接引用其中的值，指针变量则间接引用所指向内存地址中的值。指针变量在使用前需要声明与初始化。

### 指针变量的定义

指针变量定义时，需要指定所指向的数据类型。声明指针变量的一般形式为：

```c++
数据类型 *变量名；
```

“*”运算符通常称为间接运算符或间接引用运算符，在声明中以这种方式使用间接运算符时，它用以表明被声明的变量是指针变量。如下列源代码所示：

```c++
int*pl; //声明一个整型指针变量
char*pc; //声明一个字符型指针变量
float*p; //声明一个单精度浮点型指针变量
```

声明为整型的指针变量只能指向整型变量或者整型变量数组元素。声明为字符型的指针变量则只能指向字符型数据。指针变量声明后，才可以写入指向某种数据类型的变量的地址，或者说是为指针变量初始化。

![](../assets/images/图8.6_指针变量赋值后的效果.png)

### 指针变量的引用

利用指针变量可直接改变内存中某一单元的值，这是一种对系统底层的访问。指针变量为复杂的操作带来便利的同时，也存在很大的安全隐患使用不当时极容易引起程序的终止甚至系统死机。利用指针变量间接引用变量的形式为

```c++
*指针变量
```

C语言有两个指针运算符，分别是取地址运算符与间接引用运算符，这两个运算符都是一元运算符，它们的优先级仅次于一元算术运算符。

## 指针与数组

数组在内存中以顺序的形式存放。数组的第一个存储单元的地址即数组的首地址。对于一维数组来说，直接引用数组名就能获得该数组的首地址。指针变量可以存放与其内容相同的数组首地址，也可以指向某一具体的数组元素。通过这种方式，多维数组也能被看作一维数组来操作，简化了数组的操作方法。

### 指针与一维数组

定义一维数组后，可定义一个与其类型相同的指针变量指向该数组。代码如下：

```c++
int i[10] = {1, 2, 3, 4, , 5, 6, 7, 8, 9, 0}, *pi;
pi = i;
pi = &i[0]; // 等价
```

![](../assets/images/图8.7_指针变量与数组的指向关系.png)

因此，可以将C语言指针指向一维数组的表示方法总结为以下3条。

- “pi+n”或“i+n”表示数组元素 in] 的地址，即“& i[n]”。数组 i 有 10 个元素，n 的取值为 0 至 9，则数组的地址可表示为“pi+0”至“pi+9”，或“i+1”至 i+9”，与& i[0] 至& i[9] 的作用一样
- 知道了数组元素的地址表示方法，` * (pi+n)` 和 ` * (i+n)` 就表示为数组的各元素即等效于 `i[n]`。
- 指向数组的指针变量也可用数组的下标形式表示为 `pi[n]`，其效果相当于 ` * (pi + n)`

### 指针与二维数组

二维数组和其他多维数组都能看作一维数组进行指针操作。如下列源代码所定义的二维数组。

```c++
int i[2][5] = {1, 2, 3, 4, , 5, 6, 7, 8, 9, 0}, *pi;
pi = i[0];
```

该数组可以视作一个表格，数组 i 与 pi 的关系如图 89 所示。如果要访问其中的元素 `i[1][2]`，则可用公式 `1 × n+2` 得到该元素的位置，引用时可写作 `*（pi+1 * n+2）`。

![](../assets/images/图8.9_二维数组与指针变量的关系.png)

二维数组每一行都有一个首地址，如 `i[0]` 代表 `&i[0][0]` 的地址，`i[1]` 代表 `i[1][0]` 的地址。

### 指针与字符串数组

字符型指针变量指向字符串数组首地址后，该指针即可当作字符串使用。字符串处理函数通常根据字符串结束符判断该字符串的长度，所以这些函数都会沿字符串首地址向后遍历，直到找到字符串结束符。下例用于简单的字符串输入与输出。

```c++
char c[20], *pc;
pc = c;

scanf("%19s", pc);
puts(pc);
```

puts 函数的作用是将字符串无格式输出，当 `*pc` 作为其参数时，会内存中将 `*pc` 所指向的地址开始，到字符串结束符之间的字符输出到终端。

如果字符数组中没有字符串结束符，则调用 printf 或 puts 输出函数后程序会出错（一直向后处理，输出很多意想不到的字符，直到遇到值为 0 的内存块）。

```c++
char *pc;//字符型数组c的首将地址赋给指针变量pc
scanf("%s", pc);//通过pc间接引用数组c，为数组c初始化
```

这是一种非常危险的用法，因为 pc 的值不可知，pc 可能指向内存中的任意位置。将字符串保存到 pc 所指向的内存单元中，可能造成非常严重的系统错误。这种用法称之为无源指针，在程序中应避免出现。

## 指针的地址分配

指针变量可指向任何类型的变量。在处理过程中，指针变量指向的变量通过传递变量的地址来实现。指针变量的取值是内存的地址，这个地址应当是安全的，不可以是随意的否则，写入内存单元的值将会使得已存放的数据或程序丢失。应使用编译系统提供的标准函数来实现地址分配。

GCC 编译器支持动态分配内存的函数 malloc 和 free，它们包含在头文件 stdlib.h 中。动态内存分配的含义是在程序执行的过程中，动态地划分内存空间供程序使用。当程序不需要使用这些内存空间，则可以将其释放。malloc 函数的作用是向操作系统申请内存，free 函数的作用是释放所申请的内存。如下列源代码所示：

```c++
#include <stdlib.h>
#include <stdio.h>

int main() {
    char *pc;

    pc = malloc(50);

    if (pc != NULL) {
        scanf("%49s", pc);

        puts(pc);
        free(pc);
        pc = NULL;
    }

    return 0;
}
```

malloc 函数的参数是长整型数值，该数值表示所申请的字节数。如果分配内存失败返回 NULL，如果成功返回所申请内存空间首地址。free 函数必须与 malloc 配对使用，在不需要所申请的内存空间后将其释放，否则会造成内存泄漏，影响操作系统和其他程序运行。另外需要注意的是，free 函数释放指向 NULL 的指针，或释放指向并非 malloc 函数所申请内存空间的指针都会造成严重的程序错误。

## 指针数组

指针数组是一种特殊的数组，这类数组存放的全部是同一数据类型的内存地址。指针数组的定义形式为：

```c++
数据类型 *数组名[长度]；
```

指向常量的指针，必须用 const 定义为常量指针，以避免修改该指针所指向的数据造成程序错误。由于 `[]` 符号比间接运算符 ` * ` 的优先级要高，所以首先是数组形式 `c[4]`，然后才是与 ` * ` 结合。这样，指针数组内包含 4 个指针 `c[0]`、`c[1`]、`c[2]` 和 `c[3]`，分别指向 4 个字符串的首地址。

## 指向指针的指针

指针变量可以指向另一个指针变量，这种操作并不是指将一个指针变量所指向的内存地址传递给另一个指针变量，而是定义一种指向指针类型变量的指针变量，可将其称之为双重指针。双重指针的定义形式为：

```c++
数据类型 **变量名;
```

代码中定义了双重指针变量 dpi，将双重指针变量指向指针变量时，必须使用取地址运算符得到指针变量自身的内存地址。通过双重指针变量间接引用所指向的变量时，因首先要获得其所指向指针变量的地址，然后再要获得所指向指针变量中保存的内存地址，所以需要用两个取地址运算符完成这两重运算。

```c++
int i, *pi, **dpi;
pi = &i;
dpi = &pi;
**dpi = 100;
printf("%d", i);
```
