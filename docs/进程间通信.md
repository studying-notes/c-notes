---
date: 2022-02-01T18:17:21+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "进程间通信"  # 文章标题
# description: "文章描述"
url:  "posts/cpp/scratches/进程间通信"  # 设置网页永久链接
tags: [ "cpp" ]  # 标签
series: [ "C/C++ 学习笔记"]  # 文章主题/文章系列
categories: [ "学习笔记"]  # 文章分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

一个个大型的应用软件往往需要众多进程协作，所以进程间通信（IPC）的重要性显而易见。Linux 系统下的进程通信机制基本上是从 UNIX 平台上的进程通信机制移植而来的主要的进程间通信机制有以下几种。

- **无名管道**（Pipe）及**命名管道**（Named pipe）：无名管道可用于具有父子关系进程间的通信；命名管道用于无父子关系的进程之间通信。无父子关系的进程可将信息发送到某个命名管道中，并通过管道名读取信息。
- **信号**（Signal）：进程间高级的通信方式，用于通知其他进程有何种事件发生。此外，进程可以向自身发送信号，还可以获得 Linux 内核发出的信号。Linux 支持 UNIX 系统早期信号函数 sigal，并从 BSD 引入了信号函数 sigaction。Sigaction 函数不仅提供了更为有效的通信机制，并保持了接口的统一，已替代 sigal 函数。
- **报文**（Message）队列：又称为**消息队列**，是以 Posix 和 System V 为标准的通信机制。报文队列克服了信号的数据结构过于简单的问题，同时也解决了管道数据流无格式和缓冲区长度受限等问题。报文队列规定了每个进程的权限，避免了仿冒信息的出现。
- **共享内存**：让多个进程访问同一个内存空间，适合于数据量极大和数据结构极为复杂的进程间通信。但这种方式牺牲了系统的安全性，所以通常与其他进程间通信形式混合使用，并避免以根用户权限执行。
- **信号量**（Semaphore）：用于解决进程的同步和相关资源抢占而设计的。
- **套接字**（Socket）：一种数据访问机制，不仅可用于进程间通信，还可用于网络通信。使用套接字最大的好处在于，Linux 下的程序能快速移植到其他类 UNX 平台上。很多高级的进程间通信机制以套接字为基础实现。
-  **D-Bus**：一种高级的进程间通信机制，以前述机制为基础实现。它提供了丰富的接口和功能，简化了程序设计难度。

## 进程间使用管道通信

本节将以管道方式为例讲解进程间通信的使用方法。管道本身是一种数据结构，遵循先进先出的原则。先进入管道的数据，也能先从管道中读岀。数据一旦读取后，就会在管道中自动删除。管道通信以管道数据结构作为内部数据存储方式，以文件系统作为数据存储媒体。Linux 系统中有两种管道，分别是无名管道和命名管道。pipe 系统调用可创建无名管道，open 系统调用可创建命名管道。下面介绍这两种管道的实现方式。

### pipe系统调用

系统调用 pipe 用来建立管道。与之相关的函数只有一个，即 pipe 函数，该函数被定义在头文件 unistd.h 中，它的一般形式是：

```c++
int pipe(int filedes[2]);
```

pipe 系统调用需要打开两个文件，文件标识符通过参数传递给 pipe 函数。文件描述符 filedes[0] 用来读数据，filedes[1] 用来写数据。调用成功时，返回值为 0，错误时返回 -1。

管道的工作方式可以总结为以下 3 个步骤。

1. 将数据写入管道

将数据写入管道使用的是 write 函数，与写入普通文件的操作方法一样。与文件不同的是，管道的长度受到限制，管道满时写入操作会被阻塞。执行写操作的进程进入睡眠状态，直到管道中的数据被读取。fcnt 函数可将管道设置为非阻塞模式，管道满时，write 函数的返回值为 0。如果写入数据长度小于管道长度，则要求一次写入完成。如果写入数据长度大于管道长度，在写完管道长度的数据时，write 函数将被阻塞。

2. 从管道读取数据

读取数据使用 read 函数实现，读取的顺序与写入顺序相同。当数据被读取后，这些数据将自动被管道清除。因此，使用管道通信的方式只能是一对一，不能由一个进程同时向多个进程传递同一数据。如果读取的管道为空，并且管道写入端口是打开的，read 函数将被阻塞。读取操作的进程进入睡眠状态，直到有数据写入管道为止。fcnt 函数也可将管道读取模式设置为非阻塞。

3. 关闭管道

管道虽然有两个端口，但**只有一个端口能被打开**，这样避免了同时对管道进行读和写的操作。关闭端口使用的是 close 函数，关闭读端口时，在管道上进行写操作的进程将收到 SIGPIPE信号。关闭写端口时，进行读操作的 read 函数将返回0。例如下例：

```c++
#include <sys/types.h>//该头文件提供系统调用的标志
#include <sys/stat.h>//该头文件提供系统状态信息和相关函数
#include <sys/uio.h>//该头文件提供进程I/O操作的相关函数
#include <unistd.h>//标准函数库
#include <fcntl.h>//文件操作相关函数库
#include <string.h>//字符串操作函数库
#include <sys/wait.h>//wait调用相关函数库
#include <stdio.h>//标准输入与输出函数库
#include <stdlib.h>//常用工具函数库


int main() {
    int fd[2], cld_pid, len;//创建文件标识符数组
    char buf[200];//创建缓冲区

    if (pipe(fd) == -1) {
        perror("create pipe");
        exit(1);
    }

    if ((cld_pid = fork()) == 0) {
        close(fd[1]);//关闭写端口
        len = read(fd[0], buf, sizeof(buf));//从读端口中读取管道内数据
        buf[len] = 0;//为缓冲区内的数据加入字符串结束符

        printf("pipe data: %s", buf);
        exit(0);
    } else {
        close(fd[0]);
        sprintf(buf, "parent send data to child %d", cld_pid);

        write(fd[1], buf, strlen(buf));
        exit(0);
    }
}
```

上述程序中首先创建了一个管道，并且将管道的文件标识符传递给 `fp[]` 数组。该数组有两个元素， `fp[0]` 是读取管道的端口， `fp[1]` 是写入管道的端口。然后，通过 fork 系统调用创建了一个子进程。父进程的操作是向管道写入数据，子进程的操作是读取管道内的数据，最后子进程将所读取的数据显示到终端上。

### dup系统调用

系统调用 dup 用来复制一个文件描述符，该操作是通过对 u 区中文件描述符复制实现的。因此，系统调用 dup 能让多个文件描述符指向同一文件，便于管道操作。与该调用相关的函数有两个，分别是 dup 函数和 dup2 函数，一般形式如下：

```c++
int dup(int oldfd);
int dup2(int oldfd, int newfd);
```

其中，oldfd 是原有的文件描述符，newfd 为指定的新文件描述符。这两个函数的区别为，dup 函数自动分配新文件描述符，并保证该文件描述符没有被使用。dup2 函数使用 newfd 参数指定新文件描述符，如果该文件描述符已存在，则覆盖对应的文件描述符。新旧文件描述符可交换使用，并共享文件锁、文件指针和文件状态。调用成功时，函数返回值为新文件描述符，否则返回 -1。例如下例：

```c++
#include <unistd.h>//标准函数库
#include <fcntl.h>//文件操作相关函数库
#include <stdio.h>//标准输入与输出函数库


int main() {
    int fd;
    if ((fd = open("output", O_CREAT | O_RDWR, 0644)) == -1) {
        perror("open or create failed");
        return 1;
    }

    close(1);
    dup(fd);
    close(fd);

    puts("output to file");

    return 0;
}
```

上述代码中，标准输出（文件描述符为 1）关闭，并将一个普通文件output 的文件描述符复制到标准输出上。因为刚关闭了文件描述符 1，文件描述符表的第一个空表项是 1，dup 函数调用将 fid 的文件描述符复制到该位置上。所以，程序以后的向标准输出写的内容都写到了文件 output 中。

## 进程间使用D-Bus通信

D-Bus 是一种高级的进程间通信机制，它由 freedesktop.org 项目提供，使用 GPL 许可证发行。D-Bus 最主要的用途是在 Linux 桌面环境中为进程提供通信，同时能将 Linux 桌面环境和 Linux 内核事件作为消息传递到进程。D-Bus 的主要概念为总线，注册后的进程可通过总线接收或传递消息，进程也可注册后等待内核事件响应，例如等待网络状态的转变或者计算机发出关机指令。目前，D-Bus 已被大多数 Linux 发行版所采用，开发者可使用 D-Bus 实现各种复杂的进程间通信任务。

### D-Bus的基本概念

D-Bus 是一个消息总线系统，其功能已涵盖进程间通信的所有需求，并具备一些特殊的用途。D-Bus 是三层架构的进程间通信系统。

- 接口层：由函数库 libdbus 提供，进程可通过该库使用 D-Bus 的能力。
- 总线层：实际上是由 D-Bus 总线守护进程提供的。它在 Linux 系统启动时运行负责进程间的消息路由和传递，其中包括 Linux 内核和 Linux 桌面环境的消息传递。
- 包装层：由一系列基于特定应用程序框架的 Wrapper 库组成 D-Bus 具备自身的协议，协议基于二进制数据设计，与数据结构和编码方式无关。该协议无须对数据进行序列化，保证了信息传递的高效性。无论是 libdbus，还是 D-Bus 总线守护进程，均不需要太大的系统开销。

总线是 D-Bus 的进程间通信机制。一个系统中通常存在多条总线，这些总线由 D-Bus 总线守护进程管理。最重要的总线为系统总线（System Bus），Linux 内核引导时，该总线就已被装入内存。只有 Linux 内核、Linux 桌面环境和权限较高的程序才能向该总线写入消息，以此保障系统的安全性，防止有恶意进程假冒 Linux 发送消息。

会话总线（Session Buses）由普通进程创建，可同时存在多条。会话总线属于某个进程私有，它用于进程间传递消息。

进程必须注册后才能收到总线中的消息，并且可同时连接到多条总线中。D-Bus 提供了匹配器（Matchers），使进程可以有选择地接收消息，另外运行进程注册回调函数，在收到指定消息时进行处理。匹配器的功能等同于路由，用于避免处理无关消息造成进程的性能下降。除此以外，D-Bus 机制的重要概念有以下几个。

- 对象：封装后的匹配器与回调函数，它以对等（per--to-peer）协议使每个消息都有一个源地址和一个目的地址。这些地址又称为对象路径，或者称之为总线名称。对象的接口是回调函数，它以类似于C+的虚拟函数实现。当一个进程注册到某个总线时，都要创建相应的消息对象。
- 消息：D-Bus的消息分为信号（signals）、方法调用（method calls）、方法返回（method returns）和错误（errors）。信号是最基本的消息，注册的进程可简单地发送信号到总线上，其他进程通过总线读取消息。方法调用是通过总线传递参数，执行另个进程接口函数的机制，用于某个进程控制另一个进程。方法返回是注册的进程在收到相关信息后，自动做岀反应的机制，由回调函数实现。错误是信号的种，是注册进程错误处理机制之一。
- 服务（Services）：进程注册的抽象。进程注册某个地址后，即可获得对应总线的服务。D-Bus提供了服务査询接口，进程可通过该接口查询某个服务是否存在。或者在服务结束时自动收到来自系统的消息。

安装D-Bus可在其官方网站下载源码编译，地址为 http://dbus.freedesktop.org 或者在终端上输入下列指令：

```shell
sudo apt-get -y install dbus libdbus-1-dev libdbus-glib-1-2 libdbus-glib-1-dev
```

```
ls /usr/include/dbus-1.0/dbus/
```

`CMakeLists.txt`

```
include_directories(
        /usr/include/glib-2.0
        /usr/include/dbus-1.0
)
```

`Makefile`

```
gcc $$(pkg-config --cflags --libs dbus-1 --libs glib-2.0) -o main main.c
```

略，代码无法正确运行。
